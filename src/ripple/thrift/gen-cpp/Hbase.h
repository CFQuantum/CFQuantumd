/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Hbase_H
#define Hbase_H

#include <thrift/TDispatchProcessor.h>
#include "hbase_types.h"

namespace apache { namespace hadoop { namespace hbase { namespace thrift {

class HbaseIf {
 public:
  virtual ~HbaseIf() {}

  /**
   * Brings a table on-line (enables it)
   * 
   * @param tableName name of the table
   */
  virtual void enableTable(const Bytes& tableName) = 0;

  /**
   * Disables a table (takes it off-line) If it is being served, the master
   * will tell the servers to stop serving it.
   * 
   * @param tableName name of the table
   */
  virtual void disableTable(const Bytes& tableName) = 0;

  /**
   * @return true if table is on-line
   * 
   * @param tableName name of the table to check
   */
  virtual bool isTableEnabled(const Bytes& tableName) = 0;
  virtual void compact(const Bytes& tableNameOrRegionName) = 0;
  virtual void majorCompact(const Bytes& tableNameOrRegionName) = 0;

  /**
   * List all the userspace tables.
   * 
   * @return returns a list of names
   */
  virtual void getTableNames(std::vector<Text> & _return) = 0;

  /**
   * List all the column families assoicated with a table.
   * 
   * @return list of column family descriptors
   * 
   * @param tableName table name
   */
  virtual void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) = 0;

  /**
   * List the regions associated with a table.
   * 
   * @return list of region descriptors
   * 
   * @param tableName table name
   */
  virtual void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) = 0;

  /**
   * Create a table with the specified column families.  The name
   * field for each ColumnDescriptor must be set and must end in a
   * colon (:). All other fields are optional and will get default
   * values if not explicitly specified.
   * 
   * @throws IllegalArgument if an input parameter is invalid
   * 
   * @throws AlreadyExists if the table name already exists
   * 
   * @param tableName name of table to create
   * 
   * @param columnFamilies list of column family descriptors
   */
  virtual void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) = 0;

  /**
   * Deletes a table
   * 
   * @throws IOError if table doesn't exist on server or there was some other
   * problem
   * 
   * @param tableName name of table to delete
   */
  virtual void deleteTable(const Text& tableName) = 0;

  /**
   * Get a single TCell for the specified table, row, and column at the
   * latest timestamp. Returns an empty list if no such value exists.
   * 
   * @return value for specified row/column
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param column column name
   * 
   * @param attributes Get attributes
   */
  virtual void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get the specified number of versions for the specified table,
   * row, and column.
   * 
   * @return list of cells for specified row/column
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param column column name
   * 
   * @param numVersions number of versions to retrieve
   * 
   * @param attributes Get attributes
   */
  virtual void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get the specified number of versions for the specified table,
   * row, and column.  Only versions less than or equal to the specified
   * timestamp will be returned.
   * 
   * @return list of cells for specified row/column
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param column column name
   * 
   * @param timestamp timestamp
   * 
   * @param numVersions number of versions to retrieve
   * 
   * @param attributes Get attributes
   */
  virtual void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get all the data for the specified table and row at the latest
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param attributes Get attributes
   */
  virtual void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get the specified columns for the specified table and row at the latest
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param columns List of columns to return, null for all columns
   * 
   * @param attributes Get attributes
   */
  virtual void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get all the data for the specified table and row at the specified
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param tableName name of the table
   * 
   * @param row row key
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Get attributes
   */
  virtual void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get the specified columns for the specified table and row at the specified
   * timestamp. Returns an empty list if the row does not exist.
   * 
   * @return TRowResult containing the row and map of columns to TCells
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param columns List of columns to return, null for all columns
   * 
   * @param timestamp
   * @param attributes Get attributes
   */
  virtual void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get all the data for the specified table and rows at the latest
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param tableName name of table
   * 
   * @param rows row keys
   * 
   * @param attributes Get attributes
   */
  virtual void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get the specified columns for the specified table and rows at the latest
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param tableName name of table
   * 
   * @param rows row keys
   * 
   * @param columns List of columns to return, null for all columns
   * 
   * @param attributes Get attributes
   */
  virtual void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get all the data for the specified table and rows at the specified
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param tableName name of the table
   * 
   * @param rows row keys
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Get attributes
   */
  virtual void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get the specified columns for the specified table and rows at the specified
   * timestamp. Returns an empty list if no rows exist.
   * 
   * @return TRowResult containing the rows and map of columns to TCells
   * 
   * @param tableName name of table
   * 
   * @param rows row keys
   * 
   * @param columns List of columns to return, null for all columns
   * 
   * @param timestamp
   * @param attributes Get attributes
   */
  virtual void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Apply a series of mutations (updates/deletes) to a row in a
   * single transaction.  If an exception is thrown, then the
   * transaction is aborted.  Default current timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param mutations list of mutation commands
   * 
   * @param attributes Mutation attributes
   */
  virtual void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) = 0;

  /**
   * Apply a series of mutations (updates/deletes) to a row in a
   * single transaction.  If an exception is thrown, then the
   * transaction is aborted.  The specified timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param mutations list of mutation commands
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Mutation attributes
   */
  virtual void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Apply a series of batches (each a series of mutations on a single row)
   * in a single transaction.  If an exception is thrown, then the
   * transaction is aborted.  Default current timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param tableName name of table
   * 
   * @param rowBatches list of row batches
   * 
   * @param attributes Mutation attributes
   */
  virtual void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) = 0;

  /**
   * Apply a series of batches (each a series of mutations on a single row)
   * in a single transaction.  If an exception is thrown, then the
   * transaction is aborted.  The specified timestamp is used, and
   * all entries will have an identical timestamp.
   * 
   * @param tableName name of table
   * 
   * @param rowBatches list of row batches
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Mutation attributes
   */
  virtual void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Atomically increment the column value specified.  Returns the next value post increment.
   * 
   * @param tableName name of table
   * 
   * @param row row to increment
   * 
   * @param column name of column
   * 
   * @param value amount to increment by
   */
  virtual int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) = 0;

  /**
   * Delete all cells that match the passed row and column.
   * 
   * @param tableName name of table
   * 
   * @param row Row to update
   * 
   * @param column name of column whose value is to be deleted
   * 
   * @param attributes Delete attributes
   */
  virtual void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) = 0;

  /**
   * Delete all cells that match the passed row and column and whose
   * timestamp is equal-to or older than the passed timestamp.
   * 
   * @param tableName name of table
   * 
   * @param row Row to update
   * 
   * @param column name of column whose value is to be deleted
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Delete attributes
   */
  virtual void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Completely delete the row's cells.
   * 
   * @param tableName name of table
   * 
   * @param row key of the row to be completely deleted.
   * 
   * @param attributes Delete attributes
   */
  virtual void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;

  /**
   * Increment a cell by the ammount.
   * Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
   * False is the default.  Turn to true if you need the extra performance and can accept some
   * data loss if a thrift server dies with increments still in the queue.
   * 
   * @param increment The single increment to apply
   */
  virtual void increment(const TIncrement& increment) = 0;
  virtual void incrementRows(const std::vector<TIncrement> & increments) = 0;

  /**
   * Completely delete the row's cells marked with a timestamp
   * equal-to or older than the passed timestamp.
   * 
   * @param tableName name of table
   * 
   * @param row key of the row to be completely deleted.
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Delete attributes
   */
  virtual void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get a scanner on the current table, using the Scan instance
   * for the scan parameters.
   * 
   * @param tableName name of table
   * 
   * @param scan Scan instance
   * 
   * @param attributes Scan attributes
   */
  virtual ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get a scanner on the current table starting at the specified row and
   * ending at the last row in the table.  Return the specified columns.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param tableName name of table
   * 
   * @param startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param attributes Scan attributes
   */
  virtual ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get a scanner on the current table starting and stopping at the
   * specified rows.  ending at the last row in the table.  Return the
   * specified columns.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param tableName name of table
   * 
   * @param startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param stopRow row to stop scanning on. This row is *not* included in the
   * scanner's results
   * 
   * @param columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param attributes Scan attributes
   */
  virtual ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;

  /**
   * Open a scanner for a given prefix.  That is all rows will have the specified
   * prefix. No other rows will be returned.
   * 
   * @return scanner id to use with other scanner calls
   * 
   * @param tableName name of table
   * 
   * @param startAndPrefix the prefix (and thus start row) of the keys you want
   * 
   * @param columns the columns you want returned
   * 
   * @param attributes Scan attributes
   */
  virtual ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get a scanner on the current table starting at the specified row and
   * ending at the last row in the table.  Return the specified columns.
   * Only values with the specified timestamp are returned.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param tableName name of table
   * 
   * @param startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Scan attributes
   */
  virtual ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Get a scanner on the current table starting and stopping at the
   * specified rows.  ending at the last row in the table.  Return the
   * specified columns.  Only values with the specified timestamp are
   * returned.
   * 
   * @return scanner id to be used with other scanner procedures
   * 
   * @param tableName name of table
   * 
   * @param startRow Starting row in table to scan.
   * Send "" (empty string) to start at the first row.
   * 
   * @param stopRow row to stop scanning on. This row is *not* included in the
   * scanner's results
   * 
   * @param columns columns to scan. If column name is a column family, all
   * columns of the specified column family are returned. It's also possible
   * to pass a regex in the column qualifier.
   * 
   * @param timestamp timestamp
   * 
   * @param attributes Scan attributes
   */
  virtual ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;

  /**
   * Returns the scanner's current row value and advances to the next
   * row in the table.  When there are no more rows in the table, or a key
   * greater-than-or-equal-to the scanner's specified stopRow is reached,
   * an empty list is returned.
   * 
   * @return a TRowResult containing the current row and a map of the columns to TCells.
   * 
   * @throws IllegalArgument if ScannerID is invalid
   * 
   * @throws NotFound when the scanner reaches the end
   * 
   * @param id id of a scanner returned by scannerOpen
   */
  virtual void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) = 0;

  /**
   * Returns, starting at the scanner's current row value nbRows worth of
   * rows and advances to the next row in the table.  When there are no more
   * rows in the table, or a key greater-than-or-equal-to the scanner's
   * specified stopRow is reached,  an empty list is returned.
   * 
   * @return a TRowResult containing the current row and a map of the columns to TCells.
   * 
   * @throws IllegalArgument if ScannerID is invalid
   * 
   * @throws NotFound when the scanner reaches the end
   * 
   * @param id id of a scanner returned by scannerOpen
   * 
   * @param nbRows number of results to return
   */
  virtual void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) = 0;

  /**
   * Closes the server-state associated with an open scanner.
   * 
   * @throws IllegalArgument if ScannerID is invalid
   * 
   * @param id id of a scanner returned by scannerOpen
   */
  virtual void scannerClose(const ScannerID id) = 0;

  /**
   * Get the row just before the specified one.
   * 
   * @return value for specified row/column
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param family column name
   */
  virtual void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) = 0;

  /**
   * Get the regininfo for the specified row. It scans
   * the metatable to find region's start and end keys.
   * 
   * @return value for specified row/column
   * 
   * @param row row key
   */
  virtual void getRegionInfo(TRegionInfo& _return, const Text& row) = 0;

  /**
   * Appends values to one or more columns within a single row.
   * 
   * @return values of columns after the append operation.
   * 
   * @param append The single append operation to apply
   */
  virtual void append(std::vector<TCell> & _return, const TAppend& append) = 0;

  /**
   * Atomically checks if a row/family/qualifier value matches the expected
   * value. If it does, it adds the corresponding mutation operation for put.
   * 
   * @return true if the new put was executed, false otherwise
   * 
   * @param tableName name of table
   * 
   * @param row row key
   * 
   * @param column column name
   * 
   * @param value the expected value for the column parameter, if not
   * provided the check is for the non-existence of the
   * column in question
   * 
   * @param mput mutation for the put
   * 
   * @param attributes Mutation attributes
   */
  virtual bool checkAndPut(const Text& tableName, const Text& row, const Text& column, const Text& value, const Mutation& mput, const std::map<Text, Text> & attributes) = 0;
};

class HbaseIfFactory {
 public:
  typedef HbaseIf Handler;

  virtual ~HbaseIfFactory() {}

  virtual HbaseIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(HbaseIf* /* handler */) = 0;
};

class HbaseIfSingletonFactory : virtual public HbaseIfFactory {
 public:
  HbaseIfSingletonFactory(const boost::shared_ptr<HbaseIf>& iface) : iface_(iface) {}
  virtual ~HbaseIfSingletonFactory() {}

  virtual HbaseIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(HbaseIf* /* handler */) {}

 protected:
  boost::shared_ptr<HbaseIf> iface_;
};

class HbaseNull : virtual public HbaseIf {
 public:
  virtual ~HbaseNull() {}
  void enableTable(const Bytes& /* tableName */) {
    return;
  }
  void disableTable(const Bytes& /* tableName */) {
    return;
  }
  bool isTableEnabled(const Bytes& /* tableName */) {
    bool _return = false;
    return _return;
  }
  void compact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void majorCompact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void getTableNames(std::vector<Text> & /* _return */) {
    return;
  }
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void getTableRegions(std::vector<TRegionInfo> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void createTable(const Text& /* tableName */, const std::vector<ColumnDescriptor> & /* columnFamilies */) {
    return;
  }
  void deleteTable(const Text& /* tableName */) {
    return;
  }
  void get(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getVer(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int32_t /* numVersions */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getVerTs(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const int32_t /* numVersions */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRow(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRows(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRow(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowTs(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRows(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowsTs(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  int64_t atomicIncrement(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* value */) {
    int64_t _return = 0;
    return _return;
  }
  void deleteAll(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllTs(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllRow(const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void increment(const TIncrement& /* increment */) {
    return;
  }
  void incrementRows(const std::vector<TIncrement> & /* increments */) {
    return;
  }
  void deleteAllRowTs(const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  ScannerID scannerOpenWithScan(const Text& /* tableName */, const TScan& /* scan */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpen(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStop(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithPrefix(const Text& /* tableName */, const Text& /* startAndPrefix */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenTs(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  void scannerGet(std::vector<TRowResult> & /* _return */, const ScannerID /* id */) {
    return;
  }
  void scannerGetList(std::vector<TRowResult> & /* _return */, const ScannerID /* id */, const int32_t /* nbRows */) {
    return;
  }
  void scannerClose(const ScannerID /* id */) {
    return;
  }
  void getRowOrBefore(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* family */) {
    return;
  }
  void getRegionInfo(TRegionInfo& /* _return */, const Text& /* row */) {
    return;
  }
  void append(std::vector<TCell> & /* _return */, const TAppend& /* append */) {
    return;
  }
  bool checkAndPut(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const Text& /* value */, const Mutation& /* mput */, const std::map<Text, Text> & /* attributes */) {
    bool _return = false;
    return _return;
  }
};

typedef struct _Hbase_enableTable_args__isset {
  _Hbase_enableTable_args__isset() : tableName(false) {}
  bool tableName :1;
} _Hbase_enableTable_args__isset;

class Hbase_enableTable_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_enableTable_args(const Hbase_enableTable_args&);
  Hbase_enableTable_args& operator=(const Hbase_enableTable_args&);
  Hbase_enableTable_args() : tableName() {
  }

  virtual ~Hbase_enableTable_args() throw();
  Bytes tableName;

  _Hbase_enableTable_args__isset __isset;

  void __set_tableName(const Bytes& val);

  bool operator == (const Hbase_enableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_enableTable_args& obj);
};


class Hbase_enableTable_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_enableTable_pargs() throw();
  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_enableTable_pargs& obj);
};

typedef struct _Hbase_enableTable_result__isset {
  _Hbase_enableTable_result__isset() : io(false) {}
  bool io :1;
} _Hbase_enableTable_result__isset;

class Hbase_enableTable_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_enableTable_result(const Hbase_enableTable_result&);
  Hbase_enableTable_result& operator=(const Hbase_enableTable_result&);
  Hbase_enableTable_result() {
  }

  virtual ~Hbase_enableTable_result() throw();
  IOError io;

  _Hbase_enableTable_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_enableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_enableTable_result& obj);
};

typedef struct _Hbase_enableTable_presult__isset {
  _Hbase_enableTable_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_enableTable_presult__isset;

class Hbase_enableTable_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_enableTable_presult() throw();
  IOError io;

  _Hbase_enableTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_enableTable_presult& obj);
};

typedef struct _Hbase_disableTable_args__isset {
  _Hbase_disableTable_args__isset() : tableName(false) {}
  bool tableName :1;
} _Hbase_disableTable_args__isset;

class Hbase_disableTable_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_disableTable_args(const Hbase_disableTable_args&);
  Hbase_disableTable_args& operator=(const Hbase_disableTable_args&);
  Hbase_disableTable_args() : tableName() {
  }

  virtual ~Hbase_disableTable_args() throw();
  Bytes tableName;

  _Hbase_disableTable_args__isset __isset;

  void __set_tableName(const Bytes& val);

  bool operator == (const Hbase_disableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_disableTable_args& obj);
};


class Hbase_disableTable_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_disableTable_pargs() throw();
  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_disableTable_pargs& obj);
};

typedef struct _Hbase_disableTable_result__isset {
  _Hbase_disableTable_result__isset() : io(false) {}
  bool io :1;
} _Hbase_disableTable_result__isset;

class Hbase_disableTable_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_disableTable_result(const Hbase_disableTable_result&);
  Hbase_disableTable_result& operator=(const Hbase_disableTable_result&);
  Hbase_disableTable_result() {
  }

  virtual ~Hbase_disableTable_result() throw();
  IOError io;

  _Hbase_disableTable_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_disableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_disableTable_result& obj);
};

typedef struct _Hbase_disableTable_presult__isset {
  _Hbase_disableTable_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_disableTable_presult__isset;

class Hbase_disableTable_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_disableTable_presult() throw();
  IOError io;

  _Hbase_disableTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_disableTable_presult& obj);
};

typedef struct _Hbase_isTableEnabled_args__isset {
  _Hbase_isTableEnabled_args__isset() : tableName(false) {}
  bool tableName :1;
} _Hbase_isTableEnabled_args__isset;

class Hbase_isTableEnabled_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_isTableEnabled_args(const Hbase_isTableEnabled_args&);
  Hbase_isTableEnabled_args& operator=(const Hbase_isTableEnabled_args&);
  Hbase_isTableEnabled_args() : tableName() {
  }

  virtual ~Hbase_isTableEnabled_args() throw();
  Bytes tableName;

  _Hbase_isTableEnabled_args__isset __isset;

  void __set_tableName(const Bytes& val);

  bool operator == (const Hbase_isTableEnabled_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_isTableEnabled_args& obj);
};


class Hbase_isTableEnabled_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_isTableEnabled_pargs() throw();
  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_isTableEnabled_pargs& obj);
};

typedef struct _Hbase_isTableEnabled_result__isset {
  _Hbase_isTableEnabled_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_isTableEnabled_result__isset;

class Hbase_isTableEnabled_result {
 public:

  static const char* ascii_fingerprint; // = "FB3C6215AF7D1EFB061C9941F4721D27";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3C,0x62,0x15,0xAF,0x7D,0x1E,0xFB,0x06,0x1C,0x99,0x41,0xF4,0x72,0x1D,0x27};

  Hbase_isTableEnabled_result(const Hbase_isTableEnabled_result&);
  Hbase_isTableEnabled_result& operator=(const Hbase_isTableEnabled_result&);
  Hbase_isTableEnabled_result() : success(0) {
  }

  virtual ~Hbase_isTableEnabled_result() throw();
  bool success;
  IOError io;

  _Hbase_isTableEnabled_result__isset __isset;

  void __set_success(const bool val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_isTableEnabled_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_isTableEnabled_result& obj);
};

typedef struct _Hbase_isTableEnabled_presult__isset {
  _Hbase_isTableEnabled_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_isTableEnabled_presult__isset;

class Hbase_isTableEnabled_presult {
 public:

  static const char* ascii_fingerprint; // = "FB3C6215AF7D1EFB061C9941F4721D27";
  static const uint8_t binary_fingerprint[16]; // = {0xFB,0x3C,0x62,0x15,0xAF,0x7D,0x1E,0xFB,0x06,0x1C,0x99,0x41,0xF4,0x72,0x1D,0x27};


  virtual ~Hbase_isTableEnabled_presult() throw();
  bool* success;
  IOError io;

  _Hbase_isTableEnabled_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_isTableEnabled_presult& obj);
};

typedef struct _Hbase_compact_args__isset {
  _Hbase_compact_args__isset() : tableNameOrRegionName(false) {}
  bool tableNameOrRegionName :1;
} _Hbase_compact_args__isset;

class Hbase_compact_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_compact_args(const Hbase_compact_args&);
  Hbase_compact_args& operator=(const Hbase_compact_args&);
  Hbase_compact_args() : tableNameOrRegionName() {
  }

  virtual ~Hbase_compact_args() throw();
  Bytes tableNameOrRegionName;

  _Hbase_compact_args__isset __isset;

  void __set_tableNameOrRegionName(const Bytes& val);

  bool operator == (const Hbase_compact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_compact_args& obj);
};


class Hbase_compact_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_compact_pargs() throw();
  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_compact_pargs& obj);
};

typedef struct _Hbase_compact_result__isset {
  _Hbase_compact_result__isset() : io(false) {}
  bool io :1;
} _Hbase_compact_result__isset;

class Hbase_compact_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_compact_result(const Hbase_compact_result&);
  Hbase_compact_result& operator=(const Hbase_compact_result&);
  Hbase_compact_result() {
  }

  virtual ~Hbase_compact_result() throw();
  IOError io;

  _Hbase_compact_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_compact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_compact_result& obj);
};

typedef struct _Hbase_compact_presult__isset {
  _Hbase_compact_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_compact_presult__isset;

class Hbase_compact_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_compact_presult() throw();
  IOError io;

  _Hbase_compact_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_compact_presult& obj);
};

typedef struct _Hbase_majorCompact_args__isset {
  _Hbase_majorCompact_args__isset() : tableNameOrRegionName(false) {}
  bool tableNameOrRegionName :1;
} _Hbase_majorCompact_args__isset;

class Hbase_majorCompact_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_majorCompact_args(const Hbase_majorCompact_args&);
  Hbase_majorCompact_args& operator=(const Hbase_majorCompact_args&);
  Hbase_majorCompact_args() : tableNameOrRegionName() {
  }

  virtual ~Hbase_majorCompact_args() throw();
  Bytes tableNameOrRegionName;

  _Hbase_majorCompact_args__isset __isset;

  void __set_tableNameOrRegionName(const Bytes& val);

  bool operator == (const Hbase_majorCompact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_majorCompact_args& obj);
};


class Hbase_majorCompact_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_majorCompact_pargs() throw();
  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_majorCompact_pargs& obj);
};

typedef struct _Hbase_majorCompact_result__isset {
  _Hbase_majorCompact_result__isset() : io(false) {}
  bool io :1;
} _Hbase_majorCompact_result__isset;

class Hbase_majorCompact_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_majorCompact_result(const Hbase_majorCompact_result&);
  Hbase_majorCompact_result& operator=(const Hbase_majorCompact_result&);
  Hbase_majorCompact_result() {
  }

  virtual ~Hbase_majorCompact_result() throw();
  IOError io;

  _Hbase_majorCompact_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_majorCompact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_majorCompact_result& obj);
};

typedef struct _Hbase_majorCompact_presult__isset {
  _Hbase_majorCompact_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_majorCompact_presult__isset;

class Hbase_majorCompact_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_majorCompact_presult() throw();
  IOError io;

  _Hbase_majorCompact_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_majorCompact_presult& obj);
};


class Hbase_getTableNames_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  Hbase_getTableNames_args(const Hbase_getTableNames_args&);
  Hbase_getTableNames_args& operator=(const Hbase_getTableNames_args&);
  Hbase_getTableNames_args() {
  }

  virtual ~Hbase_getTableNames_args() throw();

  bool operator == (const Hbase_getTableNames_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Hbase_getTableNames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableNames_args& obj);
};


class Hbase_getTableNames_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~Hbase_getTableNames_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableNames_pargs& obj);
};

typedef struct _Hbase_getTableNames_result__isset {
  _Hbase_getTableNames_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getTableNames_result__isset;

class Hbase_getTableNames_result {
 public:

  static const char* ascii_fingerprint; // = "96F383CF9CB8BE09061ECB825FE717B6";
  static const uint8_t binary_fingerprint[16]; // = {0x96,0xF3,0x83,0xCF,0x9C,0xB8,0xBE,0x09,0x06,0x1E,0xCB,0x82,0x5F,0xE7,0x17,0xB6};

  Hbase_getTableNames_result(const Hbase_getTableNames_result&);
  Hbase_getTableNames_result& operator=(const Hbase_getTableNames_result&);
  Hbase_getTableNames_result() {
  }

  virtual ~Hbase_getTableNames_result() throw();
  std::vector<Text>  success;
  IOError io;

  _Hbase_getTableNames_result__isset __isset;

  void __set_success(const std::vector<Text> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getTableNames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableNames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableNames_result& obj);
};

typedef struct _Hbase_getTableNames_presult__isset {
  _Hbase_getTableNames_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getTableNames_presult__isset;

class Hbase_getTableNames_presult {
 public:

  static const char* ascii_fingerprint; // = "96F383CF9CB8BE09061ECB825FE717B6";
  static const uint8_t binary_fingerprint[16]; // = {0x96,0xF3,0x83,0xCF,0x9C,0xB8,0xBE,0x09,0x06,0x1E,0xCB,0x82,0x5F,0xE7,0x17,0xB6};


  virtual ~Hbase_getTableNames_presult() throw();
  std::vector<Text> * success;
  IOError io;

  _Hbase_getTableNames_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableNames_presult& obj);
};

typedef struct _Hbase_getColumnDescriptors_args__isset {
  _Hbase_getColumnDescriptors_args__isset() : tableName(false) {}
  bool tableName :1;
} _Hbase_getColumnDescriptors_args__isset;

class Hbase_getColumnDescriptors_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_getColumnDescriptors_args(const Hbase_getColumnDescriptors_args&);
  Hbase_getColumnDescriptors_args& operator=(const Hbase_getColumnDescriptors_args&);
  Hbase_getColumnDescriptors_args() : tableName() {
  }

  virtual ~Hbase_getColumnDescriptors_args() throw();
  Text tableName;

  _Hbase_getColumnDescriptors_args__isset __isset;

  void __set_tableName(const Text& val);

  bool operator == (const Hbase_getColumnDescriptors_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getColumnDescriptors_args& obj);
};


class Hbase_getColumnDescriptors_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_getColumnDescriptors_pargs() throw();
  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getColumnDescriptors_pargs& obj);
};

typedef struct _Hbase_getColumnDescriptors_result__isset {
  _Hbase_getColumnDescriptors_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getColumnDescriptors_result__isset;

class Hbase_getColumnDescriptors_result {
 public:

  static const char* ascii_fingerprint; // = "01A6DB8233B8780D84C1235900B6A715";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xA6,0xDB,0x82,0x33,0xB8,0x78,0x0D,0x84,0xC1,0x23,0x59,0x00,0xB6,0xA7,0x15};

  Hbase_getColumnDescriptors_result(const Hbase_getColumnDescriptors_result&);
  Hbase_getColumnDescriptors_result& operator=(const Hbase_getColumnDescriptors_result&);
  Hbase_getColumnDescriptors_result() {
  }

  virtual ~Hbase_getColumnDescriptors_result() throw();
  std::map<Text, ColumnDescriptor>  success;
  IOError io;

  _Hbase_getColumnDescriptors_result__isset __isset;

  void __set_success(const std::map<Text, ColumnDescriptor> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getColumnDescriptors_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getColumnDescriptors_result& obj);
};

typedef struct _Hbase_getColumnDescriptors_presult__isset {
  _Hbase_getColumnDescriptors_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getColumnDescriptors_presult__isset;

class Hbase_getColumnDescriptors_presult {
 public:

  static const char* ascii_fingerprint; // = "01A6DB8233B8780D84C1235900B6A715";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xA6,0xDB,0x82,0x33,0xB8,0x78,0x0D,0x84,0xC1,0x23,0x59,0x00,0xB6,0xA7,0x15};


  virtual ~Hbase_getColumnDescriptors_presult() throw();
  std::map<Text, ColumnDescriptor> * success;
  IOError io;

  _Hbase_getColumnDescriptors_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getColumnDescriptors_presult& obj);
};

typedef struct _Hbase_getTableRegions_args__isset {
  _Hbase_getTableRegions_args__isset() : tableName(false) {}
  bool tableName :1;
} _Hbase_getTableRegions_args__isset;

class Hbase_getTableRegions_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_getTableRegions_args(const Hbase_getTableRegions_args&);
  Hbase_getTableRegions_args& operator=(const Hbase_getTableRegions_args&);
  Hbase_getTableRegions_args() : tableName() {
  }

  virtual ~Hbase_getTableRegions_args() throw();
  Text tableName;

  _Hbase_getTableRegions_args__isset __isset;

  void __set_tableName(const Text& val);

  bool operator == (const Hbase_getTableRegions_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableRegions_args& obj);
};


class Hbase_getTableRegions_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_getTableRegions_pargs() throw();
  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableRegions_pargs& obj);
};

typedef struct _Hbase_getTableRegions_result__isset {
  _Hbase_getTableRegions_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getTableRegions_result__isset;

class Hbase_getTableRegions_result {
 public:

  static const char* ascii_fingerprint; // = "EADBEC73326330E2BA3FC3674237D8CF";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xDB,0xEC,0x73,0x32,0x63,0x30,0xE2,0xBA,0x3F,0xC3,0x67,0x42,0x37,0xD8,0xCF};

  Hbase_getTableRegions_result(const Hbase_getTableRegions_result&);
  Hbase_getTableRegions_result& operator=(const Hbase_getTableRegions_result&);
  Hbase_getTableRegions_result() {
  }

  virtual ~Hbase_getTableRegions_result() throw();
  std::vector<TRegionInfo>  success;
  IOError io;

  _Hbase_getTableRegions_result__isset __isset;

  void __set_success(const std::vector<TRegionInfo> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getTableRegions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableRegions_result& obj);
};

typedef struct _Hbase_getTableRegions_presult__isset {
  _Hbase_getTableRegions_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getTableRegions_presult__isset;

class Hbase_getTableRegions_presult {
 public:

  static const char* ascii_fingerprint; // = "EADBEC73326330E2BA3FC3674237D8CF";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0xDB,0xEC,0x73,0x32,0x63,0x30,0xE2,0xBA,0x3F,0xC3,0x67,0x42,0x37,0xD8,0xCF};


  virtual ~Hbase_getTableRegions_presult() throw();
  std::vector<TRegionInfo> * success;
  IOError io;

  _Hbase_getTableRegions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getTableRegions_presult& obj);
};

typedef struct _Hbase_createTable_args__isset {
  _Hbase_createTable_args__isset() : tableName(false), columnFamilies(false) {}
  bool tableName :1;
  bool columnFamilies :1;
} _Hbase_createTable_args__isset;

class Hbase_createTable_args {
 public:

  static const char* ascii_fingerprint; // = "2EE204F8AF1BE904CFA6EF9BB2537AF9";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0xE2,0x04,0xF8,0xAF,0x1B,0xE9,0x04,0xCF,0xA6,0xEF,0x9B,0xB2,0x53,0x7A,0xF9};

  Hbase_createTable_args(const Hbase_createTable_args&);
  Hbase_createTable_args& operator=(const Hbase_createTable_args&);
  Hbase_createTable_args() : tableName() {
  }

  virtual ~Hbase_createTable_args() throw();
  Text tableName;
  std::vector<ColumnDescriptor>  columnFamilies;

  _Hbase_createTable_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_columnFamilies(const std::vector<ColumnDescriptor> & val);

  bool operator == (const Hbase_createTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(columnFamilies == rhs.columnFamilies))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_createTable_args& obj);
};


class Hbase_createTable_pargs {
 public:

  static const char* ascii_fingerprint; // = "2EE204F8AF1BE904CFA6EF9BB2537AF9";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0xE2,0x04,0xF8,0xAF,0x1B,0xE9,0x04,0xCF,0xA6,0xEF,0x9B,0xB2,0x53,0x7A,0xF9};


  virtual ~Hbase_createTable_pargs() throw();
  const Text* tableName;
  const std::vector<ColumnDescriptor> * columnFamilies;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_createTable_pargs& obj);
};

typedef struct _Hbase_createTable_result__isset {
  _Hbase_createTable_result__isset() : io(false), ia(false), exist(false) {}
  bool io :1;
  bool ia :1;
  bool exist :1;
} _Hbase_createTable_result__isset;

class Hbase_createTable_result {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};

  Hbase_createTable_result(const Hbase_createTable_result&);
  Hbase_createTable_result& operator=(const Hbase_createTable_result&);
  Hbase_createTable_result() {
  }

  virtual ~Hbase_createTable_result() throw();
  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  _Hbase_createTable_result__isset __isset;

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  void __set_exist(const AlreadyExists& val);

  bool operator == (const Hbase_createTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    if (!(exist == rhs.exist))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_createTable_result& obj);
};

typedef struct _Hbase_createTable_presult__isset {
  _Hbase_createTable_presult__isset() : io(false), ia(false), exist(false) {}
  bool io :1;
  bool ia :1;
  bool exist :1;
} _Hbase_createTable_presult__isset;

class Hbase_createTable_presult {
 public:

  static const char* ascii_fingerprint; // = "2E72786EE0F17DA00FC5BDED362FE255";
  static const uint8_t binary_fingerprint[16]; // = {0x2E,0x72,0x78,0x6E,0xE0,0xF1,0x7D,0xA0,0x0F,0xC5,0xBD,0xED,0x36,0x2F,0xE2,0x55};


  virtual ~Hbase_createTable_presult() throw();
  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  _Hbase_createTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_createTable_presult& obj);
};

typedef struct _Hbase_deleteTable_args__isset {
  _Hbase_deleteTable_args__isset() : tableName(false) {}
  bool tableName :1;
} _Hbase_deleteTable_args__isset;

class Hbase_deleteTable_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_deleteTable_args(const Hbase_deleteTable_args&);
  Hbase_deleteTable_args& operator=(const Hbase_deleteTable_args&);
  Hbase_deleteTable_args() : tableName() {
  }

  virtual ~Hbase_deleteTable_args() throw();
  Text tableName;

  _Hbase_deleteTable_args__isset __isset;

  void __set_tableName(const Text& val);

  bool operator == (const Hbase_deleteTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteTable_args& obj);
};


class Hbase_deleteTable_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_deleteTable_pargs() throw();
  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteTable_pargs& obj);
};

typedef struct _Hbase_deleteTable_result__isset {
  _Hbase_deleteTable_result__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteTable_result__isset;

class Hbase_deleteTable_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_deleteTable_result(const Hbase_deleteTable_result&);
  Hbase_deleteTable_result& operator=(const Hbase_deleteTable_result&);
  Hbase_deleteTable_result() {
  }

  virtual ~Hbase_deleteTable_result() throw();
  IOError io;

  _Hbase_deleteTable_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_deleteTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteTable_result& obj);
};

typedef struct _Hbase_deleteTable_presult__isset {
  _Hbase_deleteTable_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteTable_presult__isset;

class Hbase_deleteTable_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_deleteTable_presult() throw();
  IOError io;

  _Hbase_deleteTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteTable_presult& obj);
};

typedef struct _Hbase_get_args__isset {
  _Hbase_get_args__isset() : tableName(false), row(false), column(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool attributes :1;
} _Hbase_get_args__isset;

class Hbase_get_args {
 public:

  static const char* ascii_fingerprint; // = "DD4B1A6F6F2E9C90B0A41B314EF1753F";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x4B,0x1A,0x6F,0x6F,0x2E,0x9C,0x90,0xB0,0xA4,0x1B,0x31,0x4E,0xF1,0x75,0x3F};

  Hbase_get_args(const Hbase_get_args&);
  Hbase_get_args& operator=(const Hbase_get_args&);
  Hbase_get_args() : tableName(), row(), column() {
  }

  virtual ~Hbase_get_args() throw();
  Text tableName;
  Text row;
  Text column;
  std::map<Text, Text>  attributes;

  _Hbase_get_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_get_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_get_args& obj);
};


class Hbase_get_pargs {
 public:

  static const char* ascii_fingerprint; // = "DD4B1A6F6F2E9C90B0A41B314EF1753F";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x4B,0x1A,0x6F,0x6F,0x2E,0x9C,0x90,0xB0,0xA4,0x1B,0x31,0x4E,0xF1,0x75,0x3F};


  virtual ~Hbase_get_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_get_pargs& obj);
};

typedef struct _Hbase_get_result__isset {
  _Hbase_get_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_get_result__isset;

class Hbase_get_result {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};

  Hbase_get_result(const Hbase_get_result&);
  Hbase_get_result& operator=(const Hbase_get_result&);
  Hbase_get_result() {
  }

  virtual ~Hbase_get_result() throw();
  std::vector<TCell>  success;
  IOError io;

  _Hbase_get_result__isset __isset;

  void __set_success(const std::vector<TCell> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_get_result& obj);
};

typedef struct _Hbase_get_presult__isset {
  _Hbase_get_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_get_presult__isset;

class Hbase_get_presult {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};


  virtual ~Hbase_get_presult() throw();
  std::vector<TCell> * success;
  IOError io;

  _Hbase_get_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_get_presult& obj);
};

typedef struct _Hbase_getVer_args__isset {
  _Hbase_getVer_args__isset() : tableName(false), row(false), column(false), numVersions(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool numVersions :1;
  bool attributes :1;
} _Hbase_getVer_args__isset;

class Hbase_getVer_args {
 public:

  static const char* ascii_fingerprint; // = "658084E97E6BA2724F2FF1BBFCDC7DB4";
  static const uint8_t binary_fingerprint[16]; // = {0x65,0x80,0x84,0xE9,0x7E,0x6B,0xA2,0x72,0x4F,0x2F,0xF1,0xBB,0xFC,0xDC,0x7D,0xB4};

  Hbase_getVer_args(const Hbase_getVer_args&);
  Hbase_getVer_args& operator=(const Hbase_getVer_args&);
  Hbase_getVer_args() : tableName(), row(), column(), numVersions(0) {
  }

  virtual ~Hbase_getVer_args() throw();
  Text tableName;
  Text row;
  Text column;
  int32_t numVersions;
  std::map<Text, Text>  attributes;

  _Hbase_getVer_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_numVersions(const int32_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getVer_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVer_args& obj);
};


class Hbase_getVer_pargs {
 public:

  static const char* ascii_fingerprint; // = "658084E97E6BA2724F2FF1BBFCDC7DB4";
  static const uint8_t binary_fingerprint[16]; // = {0x65,0x80,0x84,0xE9,0x7E,0x6B,0xA2,0x72,0x4F,0x2F,0xF1,0xBB,0xFC,0xDC,0x7D,0xB4};


  virtual ~Hbase_getVer_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const int32_t* numVersions;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVer_pargs& obj);
};

typedef struct _Hbase_getVer_result__isset {
  _Hbase_getVer_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getVer_result__isset;

class Hbase_getVer_result {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};

  Hbase_getVer_result(const Hbase_getVer_result&);
  Hbase_getVer_result& operator=(const Hbase_getVer_result&);
  Hbase_getVer_result() {
  }

  virtual ~Hbase_getVer_result() throw();
  std::vector<TCell>  success;
  IOError io;

  _Hbase_getVer_result__isset __isset;

  void __set_success(const std::vector<TCell> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getVer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVer_result& obj);
};

typedef struct _Hbase_getVer_presult__isset {
  _Hbase_getVer_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getVer_presult__isset;

class Hbase_getVer_presult {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};


  virtual ~Hbase_getVer_presult() throw();
  std::vector<TCell> * success;
  IOError io;

  _Hbase_getVer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVer_presult& obj);
};

typedef struct _Hbase_getVerTs_args__isset {
  _Hbase_getVerTs_args__isset() : tableName(false), row(false), column(false), timestamp(false), numVersions(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool timestamp :1;
  bool numVersions :1;
  bool attributes :1;
} _Hbase_getVerTs_args__isset;

class Hbase_getVerTs_args {
 public:

  static const char* ascii_fingerprint; // = "BBB1953E3ED0BDFC7D5D1FC7F5C6D874";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0xB1,0x95,0x3E,0x3E,0xD0,0xBD,0xFC,0x7D,0x5D,0x1F,0xC7,0xF5,0xC6,0xD8,0x74};

  Hbase_getVerTs_args(const Hbase_getVerTs_args&);
  Hbase_getVerTs_args& operator=(const Hbase_getVerTs_args&);
  Hbase_getVerTs_args() : tableName(), row(), column(), timestamp(0), numVersions(0) {
  }

  virtual ~Hbase_getVerTs_args() throw();
  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  int32_t numVersions;
  std::map<Text, Text>  attributes;

  _Hbase_getVerTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_timestamp(const int64_t val);

  void __set_numVersions(const int32_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getVerTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVerTs_args& obj);
};


class Hbase_getVerTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "BBB1953E3ED0BDFC7D5D1FC7F5C6D874";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0xB1,0x95,0x3E,0x3E,0xD0,0xBD,0xFC,0x7D,0x5D,0x1F,0xC7,0xF5,0xC6,0xD8,0x74};


  virtual ~Hbase_getVerTs_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const int32_t* numVersions;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVerTs_pargs& obj);
};

typedef struct _Hbase_getVerTs_result__isset {
  _Hbase_getVerTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getVerTs_result__isset;

class Hbase_getVerTs_result {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};

  Hbase_getVerTs_result(const Hbase_getVerTs_result&);
  Hbase_getVerTs_result& operator=(const Hbase_getVerTs_result&);
  Hbase_getVerTs_result() {
  }

  virtual ~Hbase_getVerTs_result() throw();
  std::vector<TCell>  success;
  IOError io;

  _Hbase_getVerTs_result__isset __isset;

  void __set_success(const std::vector<TCell> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getVerTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVerTs_result& obj);
};

typedef struct _Hbase_getVerTs_presult__isset {
  _Hbase_getVerTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getVerTs_presult__isset;

class Hbase_getVerTs_presult {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};


  virtual ~Hbase_getVerTs_presult() throw();
  std::vector<TCell> * success;
  IOError io;

  _Hbase_getVerTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getVerTs_presult& obj);
};

typedef struct _Hbase_getRow_args__isset {
  _Hbase_getRow_args__isset() : tableName(false), row(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool attributes :1;
} _Hbase_getRow_args__isset;

class Hbase_getRow_args {
 public:

  static const char* ascii_fingerprint; // = "B1021C32A35A2AEFCD2F57A5424159A7";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x02,0x1C,0x32,0xA3,0x5A,0x2A,0xEF,0xCD,0x2F,0x57,0xA5,0x42,0x41,0x59,0xA7};

  Hbase_getRow_args(const Hbase_getRow_args&);
  Hbase_getRow_args& operator=(const Hbase_getRow_args&);
  Hbase_getRow_args() : tableName(), row() {
  }

  virtual ~Hbase_getRow_args() throw();
  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  _Hbase_getRow_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRow_args& obj);
};


class Hbase_getRow_pargs {
 public:

  static const char* ascii_fingerprint; // = "B1021C32A35A2AEFCD2F57A5424159A7";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x02,0x1C,0x32,0xA3,0x5A,0x2A,0xEF,0xCD,0x2F,0x57,0xA5,0x42,0x41,0x59,0xA7};


  virtual ~Hbase_getRow_pargs() throw();
  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRow_pargs& obj);
};

typedef struct _Hbase_getRow_result__isset {
  _Hbase_getRow_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRow_result__isset;

class Hbase_getRow_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRow_result(const Hbase_getRow_result&);
  Hbase_getRow_result& operator=(const Hbase_getRow_result&);
  Hbase_getRow_result() {
  }

  virtual ~Hbase_getRow_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRow_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRow_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRow_result& obj);
};

typedef struct _Hbase_getRow_presult__isset {
  _Hbase_getRow_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRow_presult__isset;

class Hbase_getRow_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRow_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRow_presult& obj);
};

typedef struct _Hbase_getRowWithColumns_args__isset {
  _Hbase_getRowWithColumns_args__isset() : tableName(false), row(false), columns(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool columns :1;
  bool attributes :1;
} _Hbase_getRowWithColumns_args__isset;

class Hbase_getRowWithColumns_args {
 public:

  static const char* ascii_fingerprint; // = "D516D7AB4F7A18184DB876456A905990";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x16,0xD7,0xAB,0x4F,0x7A,0x18,0x18,0x4D,0xB8,0x76,0x45,0x6A,0x90,0x59,0x90};

  Hbase_getRowWithColumns_args(const Hbase_getRowWithColumns_args&);
  Hbase_getRowWithColumns_args& operator=(const Hbase_getRowWithColumns_args&);
  Hbase_getRowWithColumns_args() : tableName(), row() {
  }

  virtual ~Hbase_getRowWithColumns_args() throw();
  Text tableName;
  Text row;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_getRowWithColumns_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRowWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumns_args& obj);
};


class Hbase_getRowWithColumns_pargs {
 public:

  static const char* ascii_fingerprint; // = "D516D7AB4F7A18184DB876456A905990";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x16,0xD7,0xAB,0x4F,0x7A,0x18,0x18,0x4D,0xB8,0x76,0x45,0x6A,0x90,0x59,0x90};


  virtual ~Hbase_getRowWithColumns_pargs() throw();
  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumns_pargs& obj);
};

typedef struct _Hbase_getRowWithColumns_result__isset {
  _Hbase_getRowWithColumns_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowWithColumns_result__isset;

class Hbase_getRowWithColumns_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRowWithColumns_result(const Hbase_getRowWithColumns_result&);
  Hbase_getRowWithColumns_result& operator=(const Hbase_getRowWithColumns_result&);
  Hbase_getRowWithColumns_result() {
  }

  virtual ~Hbase_getRowWithColumns_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumns_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumns_result& obj);
};

typedef struct _Hbase_getRowWithColumns_presult__isset {
  _Hbase_getRowWithColumns_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowWithColumns_presult__isset;

class Hbase_getRowWithColumns_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRowWithColumns_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumns_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumns_presult& obj);
};

typedef struct _Hbase_getRowTs_args__isset {
  _Hbase_getRowTs_args__isset() : tableName(false), row(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_getRowTs_args__isset;

class Hbase_getRowTs_args {
 public:

  static const char* ascii_fingerprint; // = "116FEDC76A67EA3E0171588DD5B11366";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x6F,0xED,0xC7,0x6A,0x67,0xEA,0x3E,0x01,0x71,0x58,0x8D,0xD5,0xB1,0x13,0x66};

  Hbase_getRowTs_args(const Hbase_getRowTs_args&);
  Hbase_getRowTs_args& operator=(const Hbase_getRowTs_args&);
  Hbase_getRowTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_getRowTs_args() throw();
  Text tableName;
  Text row;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowTs_args& obj);
};


class Hbase_getRowTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "116FEDC76A67EA3E0171588DD5B11366";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x6F,0xED,0xC7,0x6A,0x67,0xEA,0x3E,0x01,0x71,0x58,0x8D,0xD5,0xB1,0x13,0x66};


  virtual ~Hbase_getRowTs_pargs() throw();
  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowTs_pargs& obj);
};

typedef struct _Hbase_getRowTs_result__isset {
  _Hbase_getRowTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowTs_result__isset;

class Hbase_getRowTs_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRowTs_result(const Hbase_getRowTs_result&);
  Hbase_getRowTs_result& operator=(const Hbase_getRowTs_result&);
  Hbase_getRowTs_result() {
  }

  virtual ~Hbase_getRowTs_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowTs_result& obj);
};

typedef struct _Hbase_getRowTs_presult__isset {
  _Hbase_getRowTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowTs_presult__isset;

class Hbase_getRowTs_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRowTs_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowTs_presult& obj);
};

typedef struct _Hbase_getRowWithColumnsTs_args__isset {
  _Hbase_getRowWithColumnsTs_args__isset() : tableName(false), row(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool columns :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_getRowWithColumnsTs_args__isset;

class Hbase_getRowWithColumnsTs_args {
 public:

  static const char* ascii_fingerprint; // = "4869E046A9B624761B44F4FB3F01C5D3";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x69,0xE0,0x46,0xA9,0xB6,0x24,0x76,0x1B,0x44,0xF4,0xFB,0x3F,0x01,0xC5,0xD3};

  Hbase_getRowWithColumnsTs_args(const Hbase_getRowWithColumnsTs_args&);
  Hbase_getRowWithColumnsTs_args& operator=(const Hbase_getRowWithColumnsTs_args&);
  Hbase_getRowWithColumnsTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_getRowWithColumnsTs_args() throw();
  Text tableName;
  Text row;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowWithColumnsTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRowWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumnsTs_args& obj);
};


class Hbase_getRowWithColumnsTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "4869E046A9B624761B44F4FB3F01C5D3";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x69,0xE0,0x46,0xA9,0xB6,0x24,0x76,0x1B,0x44,0xF4,0xFB,0x3F,0x01,0xC5,0xD3};


  virtual ~Hbase_getRowWithColumnsTs_pargs() throw();
  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumnsTs_pargs& obj);
};

typedef struct _Hbase_getRowWithColumnsTs_result__isset {
  _Hbase_getRowWithColumnsTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowWithColumnsTs_result__isset;

class Hbase_getRowWithColumnsTs_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRowWithColumnsTs_result(const Hbase_getRowWithColumnsTs_result&);
  Hbase_getRowWithColumnsTs_result& operator=(const Hbase_getRowWithColumnsTs_result&);
  Hbase_getRowWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowWithColumnsTs_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumnsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumnsTs_result& obj);
};

typedef struct _Hbase_getRowWithColumnsTs_presult__isset {
  _Hbase_getRowWithColumnsTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowWithColumnsTs_presult__isset;

class Hbase_getRowWithColumnsTs_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRowWithColumnsTs_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumnsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowWithColumnsTs_presult& obj);
};

typedef struct _Hbase_getRows_args__isset {
  _Hbase_getRows_args__isset() : tableName(false), rows(false), attributes(false) {}
  bool tableName :1;
  bool rows :1;
  bool attributes :1;
} _Hbase_getRows_args__isset;

class Hbase_getRows_args {
 public:

  static const char* ascii_fingerprint; // = "A5D1F36D1697921F2A7749F92FCED662";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0xD1,0xF3,0x6D,0x16,0x97,0x92,0x1F,0x2A,0x77,0x49,0xF9,0x2F,0xCE,0xD6,0x62};

  Hbase_getRows_args(const Hbase_getRows_args&);
  Hbase_getRows_args& operator=(const Hbase_getRows_args&);
  Hbase_getRows_args() : tableName() {
  }

  virtual ~Hbase_getRows_args() throw();
  Text tableName;
  std::vector<Text>  rows;
  std::map<Text, Text>  attributes;

  _Hbase_getRows_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_rows(const std::vector<Text> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRows_args& obj);
};


class Hbase_getRows_pargs {
 public:

  static const char* ascii_fingerprint; // = "A5D1F36D1697921F2A7749F92FCED662";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0xD1,0xF3,0x6D,0x16,0x97,0x92,0x1F,0x2A,0x77,0x49,0xF9,0x2F,0xCE,0xD6,0x62};


  virtual ~Hbase_getRows_pargs() throw();
  const Text* tableName;
  const std::vector<Text> * rows;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRows_pargs& obj);
};

typedef struct _Hbase_getRows_result__isset {
  _Hbase_getRows_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRows_result__isset;

class Hbase_getRows_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRows_result(const Hbase_getRows_result&);
  Hbase_getRows_result& operator=(const Hbase_getRows_result&);
  Hbase_getRows_result() {
  }

  virtual ~Hbase_getRows_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRows_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRows_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRows_result& obj);
};

typedef struct _Hbase_getRows_presult__isset {
  _Hbase_getRows_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRows_presult__isset;

class Hbase_getRows_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRows_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRows_presult& obj);
};

typedef struct _Hbase_getRowsWithColumns_args__isset {
  _Hbase_getRowsWithColumns_args__isset() : tableName(false), rows(false), columns(false), attributes(false) {}
  bool tableName :1;
  bool rows :1;
  bool columns :1;
  bool attributes :1;
} _Hbase_getRowsWithColumns_args__isset;

class Hbase_getRowsWithColumns_args {
 public:

  static const char* ascii_fingerprint; // = "1E2B094DA0D2302A65DBA22C90A74265";
  static const uint8_t binary_fingerprint[16]; // = {0x1E,0x2B,0x09,0x4D,0xA0,0xD2,0x30,0x2A,0x65,0xDB,0xA2,0x2C,0x90,0xA7,0x42,0x65};

  Hbase_getRowsWithColumns_args(const Hbase_getRowsWithColumns_args&);
  Hbase_getRowsWithColumns_args& operator=(const Hbase_getRowsWithColumns_args&);
  Hbase_getRowsWithColumns_args() : tableName() {
  }

  virtual ~Hbase_getRowsWithColumns_args() throw();
  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_getRowsWithColumns_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_rows(const std::vector<Text> & val);

  void __set_columns(const std::vector<Text> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRowsWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumns_args& obj);
};


class Hbase_getRowsWithColumns_pargs {
 public:

  static const char* ascii_fingerprint; // = "1E2B094DA0D2302A65DBA22C90A74265";
  static const uint8_t binary_fingerprint[16]; // = {0x1E,0x2B,0x09,0x4D,0xA0,0xD2,0x30,0x2A,0x65,0xDB,0xA2,0x2C,0x90,0xA7,0x42,0x65};


  virtual ~Hbase_getRowsWithColumns_pargs() throw();
  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumns_pargs& obj);
};

typedef struct _Hbase_getRowsWithColumns_result__isset {
  _Hbase_getRowsWithColumns_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowsWithColumns_result__isset;

class Hbase_getRowsWithColumns_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRowsWithColumns_result(const Hbase_getRowsWithColumns_result&);
  Hbase_getRowsWithColumns_result& operator=(const Hbase_getRowsWithColumns_result&);
  Hbase_getRowsWithColumns_result() {
  }

  virtual ~Hbase_getRowsWithColumns_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsWithColumns_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowsWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumns_result& obj);
};

typedef struct _Hbase_getRowsWithColumns_presult__isset {
  _Hbase_getRowsWithColumns_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowsWithColumns_presult__isset;

class Hbase_getRowsWithColumns_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRowsWithColumns_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsWithColumns_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumns_presult& obj);
};

typedef struct _Hbase_getRowsTs_args__isset {
  _Hbase_getRowsTs_args__isset() : tableName(false), rows(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool rows :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_getRowsTs_args__isset;

class Hbase_getRowsTs_args {
 public:

  static const char* ascii_fingerprint; // = "1E0186075E18CE0029AC188248211A94";
  static const uint8_t binary_fingerprint[16]; // = {0x1E,0x01,0x86,0x07,0x5E,0x18,0xCE,0x00,0x29,0xAC,0x18,0x82,0x48,0x21,0x1A,0x94};

  Hbase_getRowsTs_args(const Hbase_getRowsTs_args&);
  Hbase_getRowsTs_args& operator=(const Hbase_getRowsTs_args&);
  Hbase_getRowsTs_args() : tableName(), timestamp(0) {
  }

  virtual ~Hbase_getRowsTs_args() throw();
  Text tableName;
  std::vector<Text>  rows;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowsTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_rows(const std::vector<Text> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsTs_args& obj);
};


class Hbase_getRowsTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "1E0186075E18CE0029AC188248211A94";
  static const uint8_t binary_fingerprint[16]; // = {0x1E,0x01,0x86,0x07,0x5E,0x18,0xCE,0x00,0x29,0xAC,0x18,0x82,0x48,0x21,0x1A,0x94};


  virtual ~Hbase_getRowsTs_pargs() throw();
  const Text* tableName;
  const std::vector<Text> * rows;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsTs_pargs& obj);
};

typedef struct _Hbase_getRowsTs_result__isset {
  _Hbase_getRowsTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowsTs_result__isset;

class Hbase_getRowsTs_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRowsTs_result(const Hbase_getRowsTs_result&);
  Hbase_getRowsTs_result& operator=(const Hbase_getRowsTs_result&);
  Hbase_getRowsTs_result() {
  }

  virtual ~Hbase_getRowsTs_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsTs_result& obj);
};

typedef struct _Hbase_getRowsTs_presult__isset {
  _Hbase_getRowsTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowsTs_presult__isset;

class Hbase_getRowsTs_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRowsTs_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsTs_presult& obj);
};

typedef struct _Hbase_getRowsWithColumnsTs_args__isset {
  _Hbase_getRowsWithColumnsTs_args__isset() : tableName(false), rows(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool rows :1;
  bool columns :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_getRowsWithColumnsTs_args__isset;

class Hbase_getRowsWithColumnsTs_args {
 public:

  static const char* ascii_fingerprint; // = "F844506E5ACD1CE0A811CFB701414047";
  static const uint8_t binary_fingerprint[16]; // = {0xF8,0x44,0x50,0x6E,0x5A,0xCD,0x1C,0xE0,0xA8,0x11,0xCF,0xB7,0x01,0x41,0x40,0x47};

  Hbase_getRowsWithColumnsTs_args(const Hbase_getRowsWithColumnsTs_args&);
  Hbase_getRowsWithColumnsTs_args& operator=(const Hbase_getRowsWithColumnsTs_args&);
  Hbase_getRowsWithColumnsTs_args() : tableName(), timestamp(0) {
  }

  virtual ~Hbase_getRowsWithColumnsTs_args() throw();
  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowsWithColumnsTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_rows(const std::vector<Text> & val);

  void __set_columns(const std::vector<Text> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_getRowsWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumnsTs_args& obj);
};


class Hbase_getRowsWithColumnsTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "F844506E5ACD1CE0A811CFB701414047";
  static const uint8_t binary_fingerprint[16]; // = {0xF8,0x44,0x50,0x6E,0x5A,0xCD,0x1C,0xE0,0xA8,0x11,0xCF,0xB7,0x01,0x41,0x40,0x47};


  virtual ~Hbase_getRowsWithColumnsTs_pargs() throw();
  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumnsTs_pargs& obj);
};

typedef struct _Hbase_getRowsWithColumnsTs_result__isset {
  _Hbase_getRowsWithColumnsTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowsWithColumnsTs_result__isset;

class Hbase_getRowsWithColumnsTs_result {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};

  Hbase_getRowsWithColumnsTs_result(const Hbase_getRowsWithColumnsTs_result&);
  Hbase_getRowsWithColumnsTs_result& operator=(const Hbase_getRowsWithColumnsTs_result&);
  Hbase_getRowsWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowsWithColumnsTs_result() throw();
  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsWithColumnsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowsWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumnsTs_result& obj);
};

typedef struct _Hbase_getRowsWithColumnsTs_presult__isset {
  _Hbase_getRowsWithColumnsTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowsWithColumnsTs_presult__isset;

class Hbase_getRowsWithColumnsTs_presult {
 public:

  static const char* ascii_fingerprint; // = "E738904F4D6FC5296EA702C8BECFFC47";
  static const uint8_t binary_fingerprint[16]; // = {0xE7,0x38,0x90,0x4F,0x4D,0x6F,0xC5,0x29,0x6E,0xA7,0x02,0xC8,0xBE,0xCF,0xFC,0x47};


  virtual ~Hbase_getRowsWithColumnsTs_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsWithColumnsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowsWithColumnsTs_presult& obj);
};

typedef struct _Hbase_mutateRow_args__isset {
  _Hbase_mutateRow_args__isset() : tableName(false), row(false), mutations(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool mutations :1;
  bool attributes :1;
} _Hbase_mutateRow_args__isset;

class Hbase_mutateRow_args {
 public:

  static const char* ascii_fingerprint; // = "000D74EDBCC77246EDECE31627CB9539";
  static const uint8_t binary_fingerprint[16]; // = {0x00,0x0D,0x74,0xED,0xBC,0xC7,0x72,0x46,0xED,0xEC,0xE3,0x16,0x27,0xCB,0x95,0x39};

  Hbase_mutateRow_args(const Hbase_mutateRow_args&);
  Hbase_mutateRow_args& operator=(const Hbase_mutateRow_args&);
  Hbase_mutateRow_args() : tableName(), row() {
  }

  virtual ~Hbase_mutateRow_args() throw();
  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRow_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_mutations(const std::vector<Mutation> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_mutateRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRow_args& obj);
};


class Hbase_mutateRow_pargs {
 public:

  static const char* ascii_fingerprint; // = "000D74EDBCC77246EDECE31627CB9539";
  static const uint8_t binary_fingerprint[16]; // = {0x00,0x0D,0x74,0xED,0xBC,0xC7,0x72,0x46,0xED,0xEC,0xE3,0x16,0x27,0xCB,0x95,0x39};


  virtual ~Hbase_mutateRow_pargs() throw();
  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRow_pargs& obj);
};

typedef struct _Hbase_mutateRow_result__isset {
  _Hbase_mutateRow_result__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRow_result__isset;

class Hbase_mutateRow_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Hbase_mutateRow_result(const Hbase_mutateRow_result&);
  Hbase_mutateRow_result& operator=(const Hbase_mutateRow_result&);
  Hbase_mutateRow_result() {
  }

  virtual ~Hbase_mutateRow_result() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRow_result__isset __isset;

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_mutateRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRow_result& obj);
};

typedef struct _Hbase_mutateRow_presult__isset {
  _Hbase_mutateRow_presult__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRow_presult__isset;

class Hbase_mutateRow_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Hbase_mutateRow_presult() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRow_presult& obj);
};

typedef struct _Hbase_mutateRowTs_args__isset {
  _Hbase_mutateRowTs_args__isset() : tableName(false), row(false), mutations(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool mutations :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_mutateRowTs_args__isset;

class Hbase_mutateRowTs_args {
 public:

  static const char* ascii_fingerprint; // = "0509BD4B3AFF9B9D441777CEF8F8F0E0";
  static const uint8_t binary_fingerprint[16]; // = {0x05,0x09,0xBD,0x4B,0x3A,0xFF,0x9B,0x9D,0x44,0x17,0x77,0xCE,0xF8,0xF8,0xF0,0xE0};

  Hbase_mutateRowTs_args(const Hbase_mutateRowTs_args&);
  Hbase_mutateRowTs_args& operator=(const Hbase_mutateRowTs_args&);
  Hbase_mutateRowTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_mutateRowTs_args() throw();
  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRowTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_mutations(const std::vector<Mutation> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_mutateRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowTs_args& obj);
};


class Hbase_mutateRowTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "0509BD4B3AFF9B9D441777CEF8F8F0E0";
  static const uint8_t binary_fingerprint[16]; // = {0x05,0x09,0xBD,0x4B,0x3A,0xFF,0x9B,0x9D,0x44,0x17,0x77,0xCE,0xF8,0xF8,0xF0,0xE0};


  virtual ~Hbase_mutateRowTs_pargs() throw();
  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowTs_pargs& obj);
};

typedef struct _Hbase_mutateRowTs_result__isset {
  _Hbase_mutateRowTs_result__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRowTs_result__isset;

class Hbase_mutateRowTs_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Hbase_mutateRowTs_result(const Hbase_mutateRowTs_result&);
  Hbase_mutateRowTs_result& operator=(const Hbase_mutateRowTs_result&);
  Hbase_mutateRowTs_result() {
  }

  virtual ~Hbase_mutateRowTs_result() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowTs_result__isset __isset;

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_mutateRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowTs_result& obj);
};

typedef struct _Hbase_mutateRowTs_presult__isset {
  _Hbase_mutateRowTs_presult__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRowTs_presult__isset;

class Hbase_mutateRowTs_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Hbase_mutateRowTs_presult() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowTs_presult& obj);
};

typedef struct _Hbase_mutateRows_args__isset {
  _Hbase_mutateRows_args__isset() : tableName(false), rowBatches(false), attributes(false) {}
  bool tableName :1;
  bool rowBatches :1;
  bool attributes :1;
} _Hbase_mutateRows_args__isset;

class Hbase_mutateRows_args {
 public:

  static const char* ascii_fingerprint; // = "8A5C7A56E73296A112EC5CA12923DD96";
  static const uint8_t binary_fingerprint[16]; // = {0x8A,0x5C,0x7A,0x56,0xE7,0x32,0x96,0xA1,0x12,0xEC,0x5C,0xA1,0x29,0x23,0xDD,0x96};

  Hbase_mutateRows_args(const Hbase_mutateRows_args&);
  Hbase_mutateRows_args& operator=(const Hbase_mutateRows_args&);
  Hbase_mutateRows_args() : tableName() {
  }

  virtual ~Hbase_mutateRows_args() throw();
  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRows_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_rowBatches(const std::vector<BatchMutation> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_mutateRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRows_args& obj);
};


class Hbase_mutateRows_pargs {
 public:

  static const char* ascii_fingerprint; // = "8A5C7A56E73296A112EC5CA12923DD96";
  static const uint8_t binary_fingerprint[16]; // = {0x8A,0x5C,0x7A,0x56,0xE7,0x32,0x96,0xA1,0x12,0xEC,0x5C,0xA1,0x29,0x23,0xDD,0x96};


  virtual ~Hbase_mutateRows_pargs() throw();
  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRows_pargs& obj);
};

typedef struct _Hbase_mutateRows_result__isset {
  _Hbase_mutateRows_result__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRows_result__isset;

class Hbase_mutateRows_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Hbase_mutateRows_result(const Hbase_mutateRows_result&);
  Hbase_mutateRows_result& operator=(const Hbase_mutateRows_result&);
  Hbase_mutateRows_result() {
  }

  virtual ~Hbase_mutateRows_result() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRows_result__isset __isset;

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_mutateRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRows_result& obj);
};

typedef struct _Hbase_mutateRows_presult__isset {
  _Hbase_mutateRows_presult__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRows_presult__isset;

class Hbase_mutateRows_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Hbase_mutateRows_presult() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRows_presult& obj);
};

typedef struct _Hbase_mutateRowsTs_args__isset {
  _Hbase_mutateRowsTs_args__isset() : tableName(false), rowBatches(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool rowBatches :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_mutateRowsTs_args__isset;

class Hbase_mutateRowsTs_args {
 public:

  static const char* ascii_fingerprint; // = "A1B13EDBA0A2385CF4CD7AD113B9A4CB";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0xB1,0x3E,0xDB,0xA0,0xA2,0x38,0x5C,0xF4,0xCD,0x7A,0xD1,0x13,0xB9,0xA4,0xCB};

  Hbase_mutateRowsTs_args(const Hbase_mutateRowsTs_args&);
  Hbase_mutateRowsTs_args& operator=(const Hbase_mutateRowsTs_args&);
  Hbase_mutateRowsTs_args() : tableName(), timestamp(0) {
  }

  virtual ~Hbase_mutateRowsTs_args() throw();
  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRowsTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_rowBatches(const std::vector<BatchMutation> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_mutateRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowsTs_args& obj);
};


class Hbase_mutateRowsTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "A1B13EDBA0A2385CF4CD7AD113B9A4CB";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0xB1,0x3E,0xDB,0xA0,0xA2,0x38,0x5C,0xF4,0xCD,0x7A,0xD1,0x13,0xB9,0xA4,0xCB};


  virtual ~Hbase_mutateRowsTs_pargs() throw();
  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowsTs_pargs& obj);
};

typedef struct _Hbase_mutateRowsTs_result__isset {
  _Hbase_mutateRowsTs_result__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRowsTs_result__isset;

class Hbase_mutateRowsTs_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Hbase_mutateRowsTs_result(const Hbase_mutateRowsTs_result&);
  Hbase_mutateRowsTs_result& operator=(const Hbase_mutateRowsTs_result&);
  Hbase_mutateRowsTs_result() {
  }

  virtual ~Hbase_mutateRowsTs_result() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowsTs_result__isset __isset;

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_mutateRowsTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowsTs_result& obj);
};

typedef struct _Hbase_mutateRowsTs_presult__isset {
  _Hbase_mutateRowsTs_presult__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_mutateRowsTs_presult__isset;

class Hbase_mutateRowsTs_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Hbase_mutateRowsTs_presult() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_mutateRowsTs_presult& obj);
};

typedef struct _Hbase_atomicIncrement_args__isset {
  _Hbase_atomicIncrement_args__isset() : tableName(false), row(false), column(false), value(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool value :1;
} _Hbase_atomicIncrement_args__isset;

class Hbase_atomicIncrement_args {
 public:

  static const char* ascii_fingerprint; // = "5F9965D46A4F3845985AC0F9B81C3C69";
  static const uint8_t binary_fingerprint[16]; // = {0x5F,0x99,0x65,0xD4,0x6A,0x4F,0x38,0x45,0x98,0x5A,0xC0,0xF9,0xB8,0x1C,0x3C,0x69};

  Hbase_atomicIncrement_args(const Hbase_atomicIncrement_args&);
  Hbase_atomicIncrement_args& operator=(const Hbase_atomicIncrement_args&);
  Hbase_atomicIncrement_args() : tableName(), row(), column(), value(0) {
  }

  virtual ~Hbase_atomicIncrement_args() throw();
  Text tableName;
  Text row;
  Text column;
  int64_t value;

  _Hbase_atomicIncrement_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_value(const int64_t val);

  bool operator == (const Hbase_atomicIncrement_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_atomicIncrement_args& obj);
};


class Hbase_atomicIncrement_pargs {
 public:

  static const char* ascii_fingerprint; // = "5F9965D46A4F3845985AC0F9B81C3C69";
  static const uint8_t binary_fingerprint[16]; // = {0x5F,0x99,0x65,0xD4,0x6A,0x4F,0x38,0x45,0x98,0x5A,0xC0,0xF9,0xB8,0x1C,0x3C,0x69};


  virtual ~Hbase_atomicIncrement_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_atomicIncrement_pargs& obj);
};

typedef struct _Hbase_atomicIncrement_result__isset {
  _Hbase_atomicIncrement_result__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_atomicIncrement_result__isset;

class Hbase_atomicIncrement_result {
 public:

  static const char* ascii_fingerprint; // = "2FAF4D86E9E31B2F30855F03784C7513";
  static const uint8_t binary_fingerprint[16]; // = {0x2F,0xAF,0x4D,0x86,0xE9,0xE3,0x1B,0x2F,0x30,0x85,0x5F,0x03,0x78,0x4C,0x75,0x13};

  Hbase_atomicIncrement_result(const Hbase_atomicIncrement_result&);
  Hbase_atomicIncrement_result& operator=(const Hbase_atomicIncrement_result&);
  Hbase_atomicIncrement_result() : success(0) {
  }

  virtual ~Hbase_atomicIncrement_result() throw();
  int64_t success;
  IOError io;
  IllegalArgument ia;

  _Hbase_atomicIncrement_result__isset __isset;

  void __set_success(const int64_t val);

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_atomicIncrement_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_atomicIncrement_result& obj);
};

typedef struct _Hbase_atomicIncrement_presult__isset {
  _Hbase_atomicIncrement_presult__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_atomicIncrement_presult__isset;

class Hbase_atomicIncrement_presult {
 public:

  static const char* ascii_fingerprint; // = "2FAF4D86E9E31B2F30855F03784C7513";
  static const uint8_t binary_fingerprint[16]; // = {0x2F,0xAF,0x4D,0x86,0xE9,0xE3,0x1B,0x2F,0x30,0x85,0x5F,0x03,0x78,0x4C,0x75,0x13};


  virtual ~Hbase_atomicIncrement_presult() throw();
  int64_t* success;
  IOError io;
  IllegalArgument ia;

  _Hbase_atomicIncrement_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_atomicIncrement_presult& obj);
};

typedef struct _Hbase_deleteAll_args__isset {
  _Hbase_deleteAll_args__isset() : tableName(false), row(false), column(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool attributes :1;
} _Hbase_deleteAll_args__isset;

class Hbase_deleteAll_args {
 public:

  static const char* ascii_fingerprint; // = "DD4B1A6F6F2E9C90B0A41B314EF1753F";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x4B,0x1A,0x6F,0x6F,0x2E,0x9C,0x90,0xB0,0xA4,0x1B,0x31,0x4E,0xF1,0x75,0x3F};

  Hbase_deleteAll_args(const Hbase_deleteAll_args&);
  Hbase_deleteAll_args& operator=(const Hbase_deleteAll_args&);
  Hbase_deleteAll_args() : tableName(), row(), column() {
  }

  virtual ~Hbase_deleteAll_args() throw();
  Text tableName;
  Text row;
  Text column;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAll_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_deleteAll_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAll_args& obj);
};


class Hbase_deleteAll_pargs {
 public:

  static const char* ascii_fingerprint; // = "DD4B1A6F6F2E9C90B0A41B314EF1753F";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0x4B,0x1A,0x6F,0x6F,0x2E,0x9C,0x90,0xB0,0xA4,0x1B,0x31,0x4E,0xF1,0x75,0x3F};


  virtual ~Hbase_deleteAll_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAll_pargs& obj);
};

typedef struct _Hbase_deleteAll_result__isset {
  _Hbase_deleteAll_result__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAll_result__isset;

class Hbase_deleteAll_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_deleteAll_result(const Hbase_deleteAll_result&);
  Hbase_deleteAll_result& operator=(const Hbase_deleteAll_result&);
  Hbase_deleteAll_result() {
  }

  virtual ~Hbase_deleteAll_result() throw();
  IOError io;

  _Hbase_deleteAll_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_deleteAll_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAll_result& obj);
};

typedef struct _Hbase_deleteAll_presult__isset {
  _Hbase_deleteAll_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAll_presult__isset;

class Hbase_deleteAll_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_deleteAll_presult() throw();
  IOError io;

  _Hbase_deleteAll_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAll_presult& obj);
};

typedef struct _Hbase_deleteAllTs_args__isset {
  _Hbase_deleteAllTs_args__isset() : tableName(false), row(false), column(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_deleteAllTs_args__isset;

class Hbase_deleteAllTs_args {
 public:

  static const char* ascii_fingerprint; // = "421F778671CD7AB308A296CD6240871F";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0x1F,0x77,0x86,0x71,0xCD,0x7A,0xB3,0x08,0xA2,0x96,0xCD,0x62,0x40,0x87,0x1F};

  Hbase_deleteAllTs_args(const Hbase_deleteAllTs_args&);
  Hbase_deleteAllTs_args& operator=(const Hbase_deleteAllTs_args&);
  Hbase_deleteAllTs_args() : tableName(), row(), column(), timestamp(0) {
  }

  virtual ~Hbase_deleteAllTs_args() throw();
  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_deleteAllTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllTs_args& obj);
};


class Hbase_deleteAllTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "421F778671CD7AB308A296CD6240871F";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0x1F,0x77,0x86,0x71,0xCD,0x7A,0xB3,0x08,0xA2,0x96,0xCD,0x62,0x40,0x87,0x1F};


  virtual ~Hbase_deleteAllTs_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllTs_pargs& obj);
};

typedef struct _Hbase_deleteAllTs_result__isset {
  _Hbase_deleteAllTs_result__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAllTs_result__isset;

class Hbase_deleteAllTs_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_deleteAllTs_result(const Hbase_deleteAllTs_result&);
  Hbase_deleteAllTs_result& operator=(const Hbase_deleteAllTs_result&);
  Hbase_deleteAllTs_result() {
  }

  virtual ~Hbase_deleteAllTs_result() throw();
  IOError io;

  _Hbase_deleteAllTs_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_deleteAllTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllTs_result& obj);
};

typedef struct _Hbase_deleteAllTs_presult__isset {
  _Hbase_deleteAllTs_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAllTs_presult__isset;

class Hbase_deleteAllTs_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_deleteAllTs_presult() throw();
  IOError io;

  _Hbase_deleteAllTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllTs_presult& obj);
};

typedef struct _Hbase_deleteAllRow_args__isset {
  _Hbase_deleteAllRow_args__isset() : tableName(false), row(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool attributes :1;
} _Hbase_deleteAllRow_args__isset;

class Hbase_deleteAllRow_args {
 public:

  static const char* ascii_fingerprint; // = "B1021C32A35A2AEFCD2F57A5424159A7";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x02,0x1C,0x32,0xA3,0x5A,0x2A,0xEF,0xCD,0x2F,0x57,0xA5,0x42,0x41,0x59,0xA7};

  Hbase_deleteAllRow_args(const Hbase_deleteAllRow_args&);
  Hbase_deleteAllRow_args& operator=(const Hbase_deleteAllRow_args&);
  Hbase_deleteAllRow_args() : tableName(), row() {
  }

  virtual ~Hbase_deleteAllRow_args() throw();
  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllRow_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_deleteAllRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRow_args& obj);
};


class Hbase_deleteAllRow_pargs {
 public:

  static const char* ascii_fingerprint; // = "B1021C32A35A2AEFCD2F57A5424159A7";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0x02,0x1C,0x32,0xA3,0x5A,0x2A,0xEF,0xCD,0x2F,0x57,0xA5,0x42,0x41,0x59,0xA7};


  virtual ~Hbase_deleteAllRow_pargs() throw();
  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRow_pargs& obj);
};

typedef struct _Hbase_deleteAllRow_result__isset {
  _Hbase_deleteAllRow_result__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAllRow_result__isset;

class Hbase_deleteAllRow_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_deleteAllRow_result(const Hbase_deleteAllRow_result&);
  Hbase_deleteAllRow_result& operator=(const Hbase_deleteAllRow_result&);
  Hbase_deleteAllRow_result() {
  }

  virtual ~Hbase_deleteAllRow_result() throw();
  IOError io;

  _Hbase_deleteAllRow_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_deleteAllRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRow_result& obj);
};

typedef struct _Hbase_deleteAllRow_presult__isset {
  _Hbase_deleteAllRow_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAllRow_presult__isset;

class Hbase_deleteAllRow_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_deleteAllRow_presult() throw();
  IOError io;

  _Hbase_deleteAllRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRow_presult& obj);
};

typedef struct _Hbase_increment_args__isset {
  _Hbase_increment_args__isset() : increment(false) {}
  bool increment :1;
} _Hbase_increment_args__isset;

class Hbase_increment_args {
 public:

  static const char* ascii_fingerprint; // = "8F31BCF20D8C4D762856AD66DE5E39EA";
  static const uint8_t binary_fingerprint[16]; // = {0x8F,0x31,0xBC,0xF2,0x0D,0x8C,0x4D,0x76,0x28,0x56,0xAD,0x66,0xDE,0x5E,0x39,0xEA};

  Hbase_increment_args(const Hbase_increment_args&);
  Hbase_increment_args& operator=(const Hbase_increment_args&);
  Hbase_increment_args() {
  }

  virtual ~Hbase_increment_args() throw();
  TIncrement increment;

  _Hbase_increment_args__isset __isset;

  void __set_increment(const TIncrement& val);

  bool operator == (const Hbase_increment_args & rhs) const
  {
    if (!(increment == rhs.increment))
      return false;
    return true;
  }
  bool operator != (const Hbase_increment_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_increment_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_increment_args& obj);
};


class Hbase_increment_pargs {
 public:

  static const char* ascii_fingerprint; // = "8F31BCF20D8C4D762856AD66DE5E39EA";
  static const uint8_t binary_fingerprint[16]; // = {0x8F,0x31,0xBC,0xF2,0x0D,0x8C,0x4D,0x76,0x28,0x56,0xAD,0x66,0xDE,0x5E,0x39,0xEA};


  virtual ~Hbase_increment_pargs() throw();
  const TIncrement* increment;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_increment_pargs& obj);
};

typedef struct _Hbase_increment_result__isset {
  _Hbase_increment_result__isset() : io(false) {}
  bool io :1;
} _Hbase_increment_result__isset;

class Hbase_increment_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_increment_result(const Hbase_increment_result&);
  Hbase_increment_result& operator=(const Hbase_increment_result&);
  Hbase_increment_result() {
  }

  virtual ~Hbase_increment_result() throw();
  IOError io;

  _Hbase_increment_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_increment_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_increment_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_increment_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_increment_result& obj);
};

typedef struct _Hbase_increment_presult__isset {
  _Hbase_increment_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_increment_presult__isset;

class Hbase_increment_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_increment_presult() throw();
  IOError io;

  _Hbase_increment_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_increment_presult& obj);
};

typedef struct _Hbase_incrementRows_args__isset {
  _Hbase_incrementRows_args__isset() : increments(false) {}
  bool increments :1;
} _Hbase_incrementRows_args__isset;

class Hbase_incrementRows_args {
 public:

  static const char* ascii_fingerprint; // = "DDDA8F891CEFA6BAEE9C7096D0B1642F";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0xDA,0x8F,0x89,0x1C,0xEF,0xA6,0xBA,0xEE,0x9C,0x70,0x96,0xD0,0xB1,0x64,0x2F};

  Hbase_incrementRows_args(const Hbase_incrementRows_args&);
  Hbase_incrementRows_args& operator=(const Hbase_incrementRows_args&);
  Hbase_incrementRows_args() {
  }

  virtual ~Hbase_incrementRows_args() throw();
  std::vector<TIncrement>  increments;

  _Hbase_incrementRows_args__isset __isset;

  void __set_increments(const std::vector<TIncrement> & val);

  bool operator == (const Hbase_incrementRows_args & rhs) const
  {
    if (!(increments == rhs.increments))
      return false;
    return true;
  }
  bool operator != (const Hbase_incrementRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_incrementRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_incrementRows_args& obj);
};


class Hbase_incrementRows_pargs {
 public:

  static const char* ascii_fingerprint; // = "DDDA8F891CEFA6BAEE9C7096D0B1642F";
  static const uint8_t binary_fingerprint[16]; // = {0xDD,0xDA,0x8F,0x89,0x1C,0xEF,0xA6,0xBA,0xEE,0x9C,0x70,0x96,0xD0,0xB1,0x64,0x2F};


  virtual ~Hbase_incrementRows_pargs() throw();
  const std::vector<TIncrement> * increments;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_incrementRows_pargs& obj);
};

typedef struct _Hbase_incrementRows_result__isset {
  _Hbase_incrementRows_result__isset() : io(false) {}
  bool io :1;
} _Hbase_incrementRows_result__isset;

class Hbase_incrementRows_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_incrementRows_result(const Hbase_incrementRows_result&);
  Hbase_incrementRows_result& operator=(const Hbase_incrementRows_result&);
  Hbase_incrementRows_result() {
  }

  virtual ~Hbase_incrementRows_result() throw();
  IOError io;

  _Hbase_incrementRows_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_incrementRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_incrementRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_incrementRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_incrementRows_result& obj);
};

typedef struct _Hbase_incrementRows_presult__isset {
  _Hbase_incrementRows_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_incrementRows_presult__isset;

class Hbase_incrementRows_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_incrementRows_presult() throw();
  IOError io;

  _Hbase_incrementRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_incrementRows_presult& obj);
};

typedef struct _Hbase_deleteAllRowTs_args__isset {
  _Hbase_deleteAllRowTs_args__isset() : tableName(false), row(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_deleteAllRowTs_args__isset;

class Hbase_deleteAllRowTs_args {
 public:

  static const char* ascii_fingerprint; // = "116FEDC76A67EA3E0171588DD5B11366";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x6F,0xED,0xC7,0x6A,0x67,0xEA,0x3E,0x01,0x71,0x58,0x8D,0xD5,0xB1,0x13,0x66};

  Hbase_deleteAllRowTs_args(const Hbase_deleteAllRowTs_args&);
  Hbase_deleteAllRowTs_args& operator=(const Hbase_deleteAllRowTs_args&);
  Hbase_deleteAllRowTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_deleteAllRowTs_args() throw();
  Text tableName;
  Text row;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllRowTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_deleteAllRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRowTs_args& obj);
};


class Hbase_deleteAllRowTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "116FEDC76A67EA3E0171588DD5B11366";
  static const uint8_t binary_fingerprint[16]; // = {0x11,0x6F,0xED,0xC7,0x6A,0x67,0xEA,0x3E,0x01,0x71,0x58,0x8D,0xD5,0xB1,0x13,0x66};


  virtual ~Hbase_deleteAllRowTs_pargs() throw();
  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRowTs_pargs& obj);
};

typedef struct _Hbase_deleteAllRowTs_result__isset {
  _Hbase_deleteAllRowTs_result__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAllRowTs_result__isset;

class Hbase_deleteAllRowTs_result {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};

  Hbase_deleteAllRowTs_result(const Hbase_deleteAllRowTs_result&);
  Hbase_deleteAllRowTs_result& operator=(const Hbase_deleteAllRowTs_result&);
  Hbase_deleteAllRowTs_result() {
  }

  virtual ~Hbase_deleteAllRowTs_result() throw();
  IOError io;

  _Hbase_deleteAllRowTs_result__isset __isset;

  void __set_io(const IOError& val);

  bool operator == (const Hbase_deleteAllRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRowTs_result& obj);
};

typedef struct _Hbase_deleteAllRowTs_presult__isset {
  _Hbase_deleteAllRowTs_presult__isset() : io(false) {}
  bool io :1;
} _Hbase_deleteAllRowTs_presult__isset;

class Hbase_deleteAllRowTs_presult {
 public:

  static const char* ascii_fingerprint; // = "771E7EF40B572D2BFAB12C49547ADCBF";
  static const uint8_t binary_fingerprint[16]; // = {0x77,0x1E,0x7E,0xF4,0x0B,0x57,0x2D,0x2B,0xFA,0xB1,0x2C,0x49,0x54,0x7A,0xDC,0xBF};


  virtual ~Hbase_deleteAllRowTs_presult() throw();
  IOError io;

  _Hbase_deleteAllRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_deleteAllRowTs_presult& obj);
};

typedef struct _Hbase_scannerOpenWithScan_args__isset {
  _Hbase_scannerOpenWithScan_args__isset() : tableName(false), scan(false), attributes(false) {}
  bool tableName :1;
  bool scan :1;
  bool attributes :1;
} _Hbase_scannerOpenWithScan_args__isset;

class Hbase_scannerOpenWithScan_args {
 public:

  static const char* ascii_fingerprint; // = "9E81EC317609385ACE924E9A95EFAECC";
  static const uint8_t binary_fingerprint[16]; // = {0x9E,0x81,0xEC,0x31,0x76,0x09,0x38,0x5A,0xCE,0x92,0x4E,0x9A,0x95,0xEF,0xAE,0xCC};

  Hbase_scannerOpenWithScan_args(const Hbase_scannerOpenWithScan_args&);
  Hbase_scannerOpenWithScan_args& operator=(const Hbase_scannerOpenWithScan_args&);
  Hbase_scannerOpenWithScan_args() : tableName() {
  }

  virtual ~Hbase_scannerOpenWithScan_args() throw();
  Text tableName;
  TScan scan;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithScan_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_scan(const TScan& val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_scannerOpenWithScan_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(scan == rhs.scan))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithScan_args& obj);
};


class Hbase_scannerOpenWithScan_pargs {
 public:

  static const char* ascii_fingerprint; // = "9E81EC317609385ACE924E9A95EFAECC";
  static const uint8_t binary_fingerprint[16]; // = {0x9E,0x81,0xEC,0x31,0x76,0x09,0x38,0x5A,0xCE,0x92,0x4E,0x9A,0x95,0xEF,0xAE,0xCC};


  virtual ~Hbase_scannerOpenWithScan_pargs() throw();
  const Text* tableName;
  const TScan* scan;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithScan_pargs& obj);
};

typedef struct _Hbase_scannerOpenWithScan_result__isset {
  _Hbase_scannerOpenWithScan_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithScan_result__isset;

class Hbase_scannerOpenWithScan_result {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};

  Hbase_scannerOpenWithScan_result(const Hbase_scannerOpenWithScan_result&);
  Hbase_scannerOpenWithScan_result& operator=(const Hbase_scannerOpenWithScan_result&);
  Hbase_scannerOpenWithScan_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithScan_result() throw();
  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithScan_result__isset __isset;

  void __set_success(const ScannerID val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_scannerOpenWithScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithScan_result& obj);
};

typedef struct _Hbase_scannerOpenWithScan_presult__isset {
  _Hbase_scannerOpenWithScan_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithScan_presult__isset;

class Hbase_scannerOpenWithScan_presult {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};


  virtual ~Hbase_scannerOpenWithScan_presult() throw();
  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithScan_presult& obj);
};

typedef struct _Hbase_scannerOpen_args__isset {
  _Hbase_scannerOpen_args__isset() : tableName(false), startRow(false), columns(false), attributes(false) {}
  bool tableName :1;
  bool startRow :1;
  bool columns :1;
  bool attributes :1;
} _Hbase_scannerOpen_args__isset;

class Hbase_scannerOpen_args {
 public:

  static const char* ascii_fingerprint; // = "D516D7AB4F7A18184DB876456A905990";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x16,0xD7,0xAB,0x4F,0x7A,0x18,0x18,0x4D,0xB8,0x76,0x45,0x6A,0x90,0x59,0x90};

  Hbase_scannerOpen_args(const Hbase_scannerOpen_args&);
  Hbase_scannerOpen_args& operator=(const Hbase_scannerOpen_args&);
  Hbase_scannerOpen_args() : tableName(), startRow() {
  }

  virtual ~Hbase_scannerOpen_args() throw();
  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpen_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_startRow(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_scannerOpen_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpen_args& obj);
};


class Hbase_scannerOpen_pargs {
 public:

  static const char* ascii_fingerprint; // = "D516D7AB4F7A18184DB876456A905990";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x16,0xD7,0xAB,0x4F,0x7A,0x18,0x18,0x4D,0xB8,0x76,0x45,0x6A,0x90,0x59,0x90};


  virtual ~Hbase_scannerOpen_pargs() throw();
  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpen_pargs& obj);
};

typedef struct _Hbase_scannerOpen_result__isset {
  _Hbase_scannerOpen_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpen_result__isset;

class Hbase_scannerOpen_result {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};

  Hbase_scannerOpen_result(const Hbase_scannerOpen_result&);
  Hbase_scannerOpen_result& operator=(const Hbase_scannerOpen_result&);
  Hbase_scannerOpen_result() : success(0) {
  }

  virtual ~Hbase_scannerOpen_result() throw();
  ScannerID success;
  IOError io;

  _Hbase_scannerOpen_result__isset __isset;

  void __set_success(const ScannerID val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_scannerOpen_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpen_result& obj);
};

typedef struct _Hbase_scannerOpen_presult__isset {
  _Hbase_scannerOpen_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpen_presult__isset;

class Hbase_scannerOpen_presult {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};


  virtual ~Hbase_scannerOpen_presult() throw();
  ScannerID* success;
  IOError io;

  _Hbase_scannerOpen_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpen_presult& obj);
};

typedef struct _Hbase_scannerOpenWithStop_args__isset {
  _Hbase_scannerOpenWithStop_args__isset() : tableName(false), startRow(false), stopRow(false), columns(false), attributes(false) {}
  bool tableName :1;
  bool startRow :1;
  bool stopRow :1;
  bool columns :1;
  bool attributes :1;
} _Hbase_scannerOpenWithStop_args__isset;

class Hbase_scannerOpenWithStop_args {
 public:

  static const char* ascii_fingerprint; // = "01D01577E075F738799AEB83A42A7C7B";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xD0,0x15,0x77,0xE0,0x75,0xF7,0x38,0x79,0x9A,0xEB,0x83,0xA4,0x2A,0x7C,0x7B};

  Hbase_scannerOpenWithStop_args(const Hbase_scannerOpenWithStop_args&);
  Hbase_scannerOpenWithStop_args& operator=(const Hbase_scannerOpenWithStop_args&);
  Hbase_scannerOpenWithStop_args() : tableName(), startRow(), stopRow() {
  }

  virtual ~Hbase_scannerOpenWithStop_args() throw();
  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithStop_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_startRow(const Text& val);

  void __set_stopRow(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_scannerOpenWithStop_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStop_args& obj);
};


class Hbase_scannerOpenWithStop_pargs {
 public:

  static const char* ascii_fingerprint; // = "01D01577E075F738799AEB83A42A7C7B";
  static const uint8_t binary_fingerprint[16]; // = {0x01,0xD0,0x15,0x77,0xE0,0x75,0xF7,0x38,0x79,0x9A,0xEB,0x83,0xA4,0x2A,0x7C,0x7B};


  virtual ~Hbase_scannerOpenWithStop_pargs() throw();
  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStop_pargs& obj);
};

typedef struct _Hbase_scannerOpenWithStop_result__isset {
  _Hbase_scannerOpenWithStop_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithStop_result__isset;

class Hbase_scannerOpenWithStop_result {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};

  Hbase_scannerOpenWithStop_result(const Hbase_scannerOpenWithStop_result&);
  Hbase_scannerOpenWithStop_result& operator=(const Hbase_scannerOpenWithStop_result&);
  Hbase_scannerOpenWithStop_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStop_result() throw();
  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStop_result__isset __isset;

  void __set_success(const ScannerID val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_scannerOpenWithStop_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStop_result& obj);
};

typedef struct _Hbase_scannerOpenWithStop_presult__isset {
  _Hbase_scannerOpenWithStop_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithStop_presult__isset;

class Hbase_scannerOpenWithStop_presult {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};


  virtual ~Hbase_scannerOpenWithStop_presult() throw();
  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStop_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStop_presult& obj);
};

typedef struct _Hbase_scannerOpenWithPrefix_args__isset {
  _Hbase_scannerOpenWithPrefix_args__isset() : tableName(false), startAndPrefix(false), columns(false), attributes(false) {}
  bool tableName :1;
  bool startAndPrefix :1;
  bool columns :1;
  bool attributes :1;
} _Hbase_scannerOpenWithPrefix_args__isset;

class Hbase_scannerOpenWithPrefix_args {
 public:

  static const char* ascii_fingerprint; // = "D516D7AB4F7A18184DB876456A905990";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x16,0xD7,0xAB,0x4F,0x7A,0x18,0x18,0x4D,0xB8,0x76,0x45,0x6A,0x90,0x59,0x90};

  Hbase_scannerOpenWithPrefix_args(const Hbase_scannerOpenWithPrefix_args&);
  Hbase_scannerOpenWithPrefix_args& operator=(const Hbase_scannerOpenWithPrefix_args&);
  Hbase_scannerOpenWithPrefix_args() : tableName(), startAndPrefix() {
  }

  virtual ~Hbase_scannerOpenWithPrefix_args() throw();
  Text tableName;
  Text startAndPrefix;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithPrefix_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_startAndPrefix(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_scannerOpenWithPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startAndPrefix == rhs.startAndPrefix))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithPrefix_args& obj);
};


class Hbase_scannerOpenWithPrefix_pargs {
 public:

  static const char* ascii_fingerprint; // = "D516D7AB4F7A18184DB876456A905990";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x16,0xD7,0xAB,0x4F,0x7A,0x18,0x18,0x4D,0xB8,0x76,0x45,0x6A,0x90,0x59,0x90};


  virtual ~Hbase_scannerOpenWithPrefix_pargs() throw();
  const Text* tableName;
  const Text* startAndPrefix;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithPrefix_pargs& obj);
};

typedef struct _Hbase_scannerOpenWithPrefix_result__isset {
  _Hbase_scannerOpenWithPrefix_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithPrefix_result__isset;

class Hbase_scannerOpenWithPrefix_result {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};

  Hbase_scannerOpenWithPrefix_result(const Hbase_scannerOpenWithPrefix_result&);
  Hbase_scannerOpenWithPrefix_result& operator=(const Hbase_scannerOpenWithPrefix_result&);
  Hbase_scannerOpenWithPrefix_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithPrefix_result() throw();
  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithPrefix_result__isset __isset;

  void __set_success(const ScannerID val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_scannerOpenWithPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithPrefix_result& obj);
};

typedef struct _Hbase_scannerOpenWithPrefix_presult__isset {
  _Hbase_scannerOpenWithPrefix_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithPrefix_presult__isset;

class Hbase_scannerOpenWithPrefix_presult {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};


  virtual ~Hbase_scannerOpenWithPrefix_presult() throw();
  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithPrefix_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithPrefix_presult& obj);
};

typedef struct _Hbase_scannerOpenTs_args__isset {
  _Hbase_scannerOpenTs_args__isset() : tableName(false), startRow(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool startRow :1;
  bool columns :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_scannerOpenTs_args__isset;

class Hbase_scannerOpenTs_args {
 public:

  static const char* ascii_fingerprint; // = "4869E046A9B624761B44F4FB3F01C5D3";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x69,0xE0,0x46,0xA9,0xB6,0x24,0x76,0x1B,0x44,0xF4,0xFB,0x3F,0x01,0xC5,0xD3};

  Hbase_scannerOpenTs_args(const Hbase_scannerOpenTs_args&);
  Hbase_scannerOpenTs_args& operator=(const Hbase_scannerOpenTs_args&);
  Hbase_scannerOpenTs_args() : tableName(), startRow(), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenTs_args() throw();
  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_startRow(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_scannerOpenTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenTs_args& obj);
};


class Hbase_scannerOpenTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "4869E046A9B624761B44F4FB3F01C5D3";
  static const uint8_t binary_fingerprint[16]; // = {0x48,0x69,0xE0,0x46,0xA9,0xB6,0x24,0x76,0x1B,0x44,0xF4,0xFB,0x3F,0x01,0xC5,0xD3};


  virtual ~Hbase_scannerOpenTs_pargs() throw();
  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenTs_pargs& obj);
};

typedef struct _Hbase_scannerOpenTs_result__isset {
  _Hbase_scannerOpenTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenTs_result__isset;

class Hbase_scannerOpenTs_result {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};

  Hbase_scannerOpenTs_result(const Hbase_scannerOpenTs_result&);
  Hbase_scannerOpenTs_result& operator=(const Hbase_scannerOpenTs_result&);
  Hbase_scannerOpenTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenTs_result() throw();
  ScannerID success;
  IOError io;

  _Hbase_scannerOpenTs_result__isset __isset;

  void __set_success(const ScannerID val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_scannerOpenTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenTs_result& obj);
};

typedef struct _Hbase_scannerOpenTs_presult__isset {
  _Hbase_scannerOpenTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenTs_presult__isset;

class Hbase_scannerOpenTs_presult {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};


  virtual ~Hbase_scannerOpenTs_presult() throw();
  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenTs_presult& obj);
};

typedef struct _Hbase_scannerOpenWithStopTs_args__isset {
  _Hbase_scannerOpenWithStopTs_args__isset() : tableName(false), startRow(false), stopRow(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName :1;
  bool startRow :1;
  bool stopRow :1;
  bool columns :1;
  bool timestamp :1;
  bool attributes :1;
} _Hbase_scannerOpenWithStopTs_args__isset;

class Hbase_scannerOpenWithStopTs_args {
 public:

  static const char* ascii_fingerprint; // = "F12025552E948B88CCBF5125B7AD36CA";
  static const uint8_t binary_fingerprint[16]; // = {0xF1,0x20,0x25,0x55,0x2E,0x94,0x8B,0x88,0xCC,0xBF,0x51,0x25,0xB7,0xAD,0x36,0xCA};

  Hbase_scannerOpenWithStopTs_args(const Hbase_scannerOpenWithStopTs_args&);
  Hbase_scannerOpenWithStopTs_args& operator=(const Hbase_scannerOpenWithStopTs_args&);
  Hbase_scannerOpenWithStopTs_args() : tableName(), startRow(), stopRow(), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_args() throw();
  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithStopTs_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_startRow(const Text& val);

  void __set_stopRow(const Text& val);

  void __set_columns(const std::vector<Text> & val);

  void __set_timestamp(const int64_t val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_scannerOpenWithStopTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStopTs_args& obj);
};


class Hbase_scannerOpenWithStopTs_pargs {
 public:

  static const char* ascii_fingerprint; // = "F12025552E948B88CCBF5125B7AD36CA";
  static const uint8_t binary_fingerprint[16]; // = {0xF1,0x20,0x25,0x55,0x2E,0x94,0x8B,0x88,0xCC,0xBF,0x51,0x25,0xB7,0xAD,0x36,0xCA};


  virtual ~Hbase_scannerOpenWithStopTs_pargs() throw();
  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStopTs_pargs& obj);
};

typedef struct _Hbase_scannerOpenWithStopTs_result__isset {
  _Hbase_scannerOpenWithStopTs_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithStopTs_result__isset;

class Hbase_scannerOpenWithStopTs_result {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};

  Hbase_scannerOpenWithStopTs_result(const Hbase_scannerOpenWithStopTs_result&);
  Hbase_scannerOpenWithStopTs_result& operator=(const Hbase_scannerOpenWithStopTs_result&);
  Hbase_scannerOpenWithStopTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_result() throw();
  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopTs_result__isset __isset;

  void __set_success(const ScannerID val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_scannerOpenWithStopTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStopTs_result& obj);
};

typedef struct _Hbase_scannerOpenWithStopTs_presult__isset {
  _Hbase_scannerOpenWithStopTs_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_scannerOpenWithStopTs_presult__isset;

class Hbase_scannerOpenWithStopTs_presult {
 public:

  static const char* ascii_fingerprint; // = "434080405F8773F4FEEED0F8CC7A6239";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x40,0x80,0x40,0x5F,0x87,0x73,0xF4,0xFE,0xEE,0xD0,0xF8,0xCC,0x7A,0x62,0x39};


  virtual ~Hbase_scannerOpenWithStopTs_presult() throw();
  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerOpenWithStopTs_presult& obj);
};

typedef struct _Hbase_scannerGet_args__isset {
  _Hbase_scannerGet_args__isset() : id(false) {}
  bool id :1;
} _Hbase_scannerGet_args__isset;

class Hbase_scannerGet_args {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  Hbase_scannerGet_args(const Hbase_scannerGet_args&);
  Hbase_scannerGet_args& operator=(const Hbase_scannerGet_args&);
  Hbase_scannerGet_args() : id(0) {
  }

  virtual ~Hbase_scannerGet_args() throw();
  ScannerID id;

  _Hbase_scannerGet_args__isset __isset;

  void __set_id(const ScannerID val);

  bool operator == (const Hbase_scannerGet_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGet_args& obj);
};


class Hbase_scannerGet_pargs {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};


  virtual ~Hbase_scannerGet_pargs() throw();
  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGet_pargs& obj);
};

typedef struct _Hbase_scannerGet_result__isset {
  _Hbase_scannerGet_result__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_scannerGet_result__isset;

class Hbase_scannerGet_result {
 public:

  static const char* ascii_fingerprint; // = "2ADE7E500ED64AD8E23AEC4352023680";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0xDE,0x7E,0x50,0x0E,0xD6,0x4A,0xD8,0xE2,0x3A,0xEC,0x43,0x52,0x02,0x36,0x80};

  Hbase_scannerGet_result(const Hbase_scannerGet_result&);
  Hbase_scannerGet_result& operator=(const Hbase_scannerGet_result&);
  Hbase_scannerGet_result() {
  }

  virtual ~Hbase_scannerGet_result() throw();
  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGet_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_scannerGet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGet_result& obj);
};

typedef struct _Hbase_scannerGet_presult__isset {
  _Hbase_scannerGet_presult__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_scannerGet_presult__isset;

class Hbase_scannerGet_presult {
 public:

  static const char* ascii_fingerprint; // = "2ADE7E500ED64AD8E23AEC4352023680";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0xDE,0x7E,0x50,0x0E,0xD6,0x4A,0xD8,0xE2,0x3A,0xEC,0x43,0x52,0x02,0x36,0x80};


  virtual ~Hbase_scannerGet_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGet_presult& obj);
};

typedef struct _Hbase_scannerGetList_args__isset {
  _Hbase_scannerGetList_args__isset() : id(false), nbRows(false) {}
  bool id :1;
  bool nbRows :1;
} _Hbase_scannerGetList_args__isset;

class Hbase_scannerGetList_args {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};

  Hbase_scannerGetList_args(const Hbase_scannerGetList_args&);
  Hbase_scannerGetList_args& operator=(const Hbase_scannerGetList_args&);
  Hbase_scannerGetList_args() : id(0), nbRows(0) {
  }

  virtual ~Hbase_scannerGetList_args() throw();
  ScannerID id;
  int32_t nbRows;

  _Hbase_scannerGetList_args__isset __isset;

  void __set_id(const ScannerID val);

  void __set_nbRows(const int32_t val);

  bool operator == (const Hbase_scannerGetList_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(nbRows == rhs.nbRows))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGetList_args& obj);
};


class Hbase_scannerGetList_pargs {
 public:

  static const char* ascii_fingerprint; // = "989D1F1AE8D148D5E2119FFEC4BBBEE3";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x9D,0x1F,0x1A,0xE8,0xD1,0x48,0xD5,0xE2,0x11,0x9F,0xFE,0xC4,0xBB,0xBE,0xE3};


  virtual ~Hbase_scannerGetList_pargs() throw();
  const ScannerID* id;
  const int32_t* nbRows;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGetList_pargs& obj);
};

typedef struct _Hbase_scannerGetList_result__isset {
  _Hbase_scannerGetList_result__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_scannerGetList_result__isset;

class Hbase_scannerGetList_result {
 public:

  static const char* ascii_fingerprint; // = "2ADE7E500ED64AD8E23AEC4352023680";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0xDE,0x7E,0x50,0x0E,0xD6,0x4A,0xD8,0xE2,0x3A,0xEC,0x43,0x52,0x02,0x36,0x80};

  Hbase_scannerGetList_result(const Hbase_scannerGetList_result&);
  Hbase_scannerGetList_result& operator=(const Hbase_scannerGetList_result&);
  Hbase_scannerGetList_result() {
  }

  virtual ~Hbase_scannerGetList_result() throw();
  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGetList_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val);

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_scannerGetList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGetList_result& obj);
};

typedef struct _Hbase_scannerGetList_presult__isset {
  _Hbase_scannerGetList_presult__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_scannerGetList_presult__isset;

class Hbase_scannerGetList_presult {
 public:

  static const char* ascii_fingerprint; // = "2ADE7E500ED64AD8E23AEC4352023680";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0xDE,0x7E,0x50,0x0E,0xD6,0x4A,0xD8,0xE2,0x3A,0xEC,0x43,0x52,0x02,0x36,0x80};


  virtual ~Hbase_scannerGetList_presult() throw();
  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGetList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerGetList_presult& obj);
};

typedef struct _Hbase_scannerClose_args__isset {
  _Hbase_scannerClose_args__isset() : id(false) {}
  bool id :1;
} _Hbase_scannerClose_args__isset;

class Hbase_scannerClose_args {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  Hbase_scannerClose_args(const Hbase_scannerClose_args&);
  Hbase_scannerClose_args& operator=(const Hbase_scannerClose_args&);
  Hbase_scannerClose_args() : id(0) {
  }

  virtual ~Hbase_scannerClose_args() throw();
  ScannerID id;

  _Hbase_scannerClose_args__isset __isset;

  void __set_id(const ScannerID val);

  bool operator == (const Hbase_scannerClose_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerClose_args& obj);
};


class Hbase_scannerClose_pargs {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};


  virtual ~Hbase_scannerClose_pargs() throw();
  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerClose_pargs& obj);
};

typedef struct _Hbase_scannerClose_result__isset {
  _Hbase_scannerClose_result__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_scannerClose_result__isset;

class Hbase_scannerClose_result {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};

  Hbase_scannerClose_result(const Hbase_scannerClose_result&);
  Hbase_scannerClose_result& operator=(const Hbase_scannerClose_result&);
  Hbase_scannerClose_result() {
  }

  virtual ~Hbase_scannerClose_result() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerClose_result__isset __isset;

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_scannerClose_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerClose_result& obj);
};

typedef struct _Hbase_scannerClose_presult__isset {
  _Hbase_scannerClose_presult__isset() : io(false), ia(false) {}
  bool io :1;
  bool ia :1;
} _Hbase_scannerClose_presult__isset;

class Hbase_scannerClose_presult {
 public:

  static const char* ascii_fingerprint; // = "A963880F55F6F22FCC67AD7BA0E1894D";
  static const uint8_t binary_fingerprint[16]; // = {0xA9,0x63,0x88,0x0F,0x55,0xF6,0xF2,0x2F,0xCC,0x67,0xAD,0x7B,0xA0,0xE1,0x89,0x4D};


  virtual ~Hbase_scannerClose_presult() throw();
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerClose_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_scannerClose_presult& obj);
};

typedef struct _Hbase_getRowOrBefore_args__isset {
  _Hbase_getRowOrBefore_args__isset() : tableName(false), row(false), family(false) {}
  bool tableName :1;
  bool row :1;
  bool family :1;
} _Hbase_getRowOrBefore_args__isset;

class Hbase_getRowOrBefore_args {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};

  Hbase_getRowOrBefore_args(const Hbase_getRowOrBefore_args&);
  Hbase_getRowOrBefore_args& operator=(const Hbase_getRowOrBefore_args&);
  Hbase_getRowOrBefore_args() : tableName(), row(), family() {
  }

  virtual ~Hbase_getRowOrBefore_args() throw();
  Text tableName;
  Text row;
  Text family;

  _Hbase_getRowOrBefore_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_family(const Text& val);

  bool operator == (const Hbase_getRowOrBefore_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(family == rhs.family))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowOrBefore_args& obj);
};


class Hbase_getRowOrBefore_pargs {
 public:

  static const char* ascii_fingerprint; // = "AB879940BD15B6B25691265F7384B271";
  static const uint8_t binary_fingerprint[16]; // = {0xAB,0x87,0x99,0x40,0xBD,0x15,0xB6,0xB2,0x56,0x91,0x26,0x5F,0x73,0x84,0xB2,0x71};


  virtual ~Hbase_getRowOrBefore_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* family;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowOrBefore_pargs& obj);
};

typedef struct _Hbase_getRowOrBefore_result__isset {
  _Hbase_getRowOrBefore_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowOrBefore_result__isset;

class Hbase_getRowOrBefore_result {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};

  Hbase_getRowOrBefore_result(const Hbase_getRowOrBefore_result&);
  Hbase_getRowOrBefore_result& operator=(const Hbase_getRowOrBefore_result&);
  Hbase_getRowOrBefore_result() {
  }

  virtual ~Hbase_getRowOrBefore_result() throw();
  std::vector<TCell>  success;
  IOError io;

  _Hbase_getRowOrBefore_result__isset __isset;

  void __set_success(const std::vector<TCell> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRowOrBefore_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowOrBefore_result& obj);
};

typedef struct _Hbase_getRowOrBefore_presult__isset {
  _Hbase_getRowOrBefore_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRowOrBefore_presult__isset;

class Hbase_getRowOrBefore_presult {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};


  virtual ~Hbase_getRowOrBefore_presult() throw();
  std::vector<TCell> * success;
  IOError io;

  _Hbase_getRowOrBefore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRowOrBefore_presult& obj);
};

typedef struct _Hbase_getRegionInfo_args__isset {
  _Hbase_getRegionInfo_args__isset() : row(false) {}
  bool row :1;
} _Hbase_getRegionInfo_args__isset;

class Hbase_getRegionInfo_args {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  Hbase_getRegionInfo_args(const Hbase_getRegionInfo_args&);
  Hbase_getRegionInfo_args& operator=(const Hbase_getRegionInfo_args&);
  Hbase_getRegionInfo_args() : row() {
  }

  virtual ~Hbase_getRegionInfo_args() throw();
  Text row;

  _Hbase_getRegionInfo_args__isset __isset;

  void __set_row(const Text& val);

  bool operator == (const Hbase_getRegionInfo_args & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRegionInfo_args& obj);
};


class Hbase_getRegionInfo_pargs {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};


  virtual ~Hbase_getRegionInfo_pargs() throw();
  const Text* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRegionInfo_pargs& obj);
};

typedef struct _Hbase_getRegionInfo_result__isset {
  _Hbase_getRegionInfo_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRegionInfo_result__isset;

class Hbase_getRegionInfo_result {
 public:

  static const char* ascii_fingerprint; // = "038FD180DB81B4A7B68F1D8C58903207";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0x8F,0xD1,0x80,0xDB,0x81,0xB4,0xA7,0xB6,0x8F,0x1D,0x8C,0x58,0x90,0x32,0x07};

  Hbase_getRegionInfo_result(const Hbase_getRegionInfo_result&);
  Hbase_getRegionInfo_result& operator=(const Hbase_getRegionInfo_result&);
  Hbase_getRegionInfo_result() {
  }

  virtual ~Hbase_getRegionInfo_result() throw();
  TRegionInfo success;
  IOError io;

  _Hbase_getRegionInfo_result__isset __isset;

  void __set_success(const TRegionInfo& val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_getRegionInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRegionInfo_result& obj);
};

typedef struct _Hbase_getRegionInfo_presult__isset {
  _Hbase_getRegionInfo_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_getRegionInfo_presult__isset;

class Hbase_getRegionInfo_presult {
 public:

  static const char* ascii_fingerprint; // = "038FD180DB81B4A7B68F1D8C58903207";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0x8F,0xD1,0x80,0xDB,0x81,0xB4,0xA7,0xB6,0x8F,0x1D,0x8C,0x58,0x90,0x32,0x07};


  virtual ~Hbase_getRegionInfo_presult() throw();
  TRegionInfo* success;
  IOError io;

  _Hbase_getRegionInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_getRegionInfo_presult& obj);
};

typedef struct _Hbase_append_args__isset {
  _Hbase_append_args__isset() : append(false) {}
  bool append :1;
} _Hbase_append_args__isset;

class Hbase_append_args {
 public:

  static const char* ascii_fingerprint; // = "A16CD6655F15DFD35925BCD2DD68C45C";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0x6C,0xD6,0x65,0x5F,0x15,0xDF,0xD3,0x59,0x25,0xBC,0xD2,0xDD,0x68,0xC4,0x5C};

  Hbase_append_args(const Hbase_append_args&);
  Hbase_append_args& operator=(const Hbase_append_args&);
  Hbase_append_args() {
  }

  virtual ~Hbase_append_args() throw();
  TAppend append;

  _Hbase_append_args__isset __isset;

  void __set_append(const TAppend& val);

  bool operator == (const Hbase_append_args & rhs) const
  {
    if (!(append == rhs.append))
      return false;
    return true;
  }
  bool operator != (const Hbase_append_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_append_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_append_args& obj);
};


class Hbase_append_pargs {
 public:

  static const char* ascii_fingerprint; // = "A16CD6655F15DFD35925BCD2DD68C45C";
  static const uint8_t binary_fingerprint[16]; // = {0xA1,0x6C,0xD6,0x65,0x5F,0x15,0xDF,0xD3,0x59,0x25,0xBC,0xD2,0xDD,0x68,0xC4,0x5C};


  virtual ~Hbase_append_pargs() throw();
  const TAppend* append;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_append_pargs& obj);
};

typedef struct _Hbase_append_result__isset {
  _Hbase_append_result__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_append_result__isset;

class Hbase_append_result {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};

  Hbase_append_result(const Hbase_append_result&);
  Hbase_append_result& operator=(const Hbase_append_result&);
  Hbase_append_result() {
  }

  virtual ~Hbase_append_result() throw();
  std::vector<TCell>  success;
  IOError io;

  _Hbase_append_result__isset __isset;

  void __set_success(const std::vector<TCell> & val);

  void __set_io(const IOError& val);

  bool operator == (const Hbase_append_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_append_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_append_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_append_result& obj);
};

typedef struct _Hbase_append_presult__isset {
  _Hbase_append_presult__isset() : success(false), io(false) {}
  bool success :1;
  bool io :1;
} _Hbase_append_presult__isset;

class Hbase_append_presult {
 public:

  static const char* ascii_fingerprint; // = "671EDE68BF52E647AD4187517CDB36CC";
  static const uint8_t binary_fingerprint[16]; // = {0x67,0x1E,0xDE,0x68,0xBF,0x52,0xE6,0x47,0xAD,0x41,0x87,0x51,0x7C,0xDB,0x36,0xCC};


  virtual ~Hbase_append_presult() throw();
  std::vector<TCell> * success;
  IOError io;

  _Hbase_append_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_append_presult& obj);
};

typedef struct _Hbase_checkAndPut_args__isset {
  _Hbase_checkAndPut_args__isset() : tableName(false), row(false), column(false), value(false), mput(false), attributes(false) {}
  bool tableName :1;
  bool row :1;
  bool column :1;
  bool value :1;
  bool mput :1;
  bool attributes :1;
} _Hbase_checkAndPut_args__isset;

class Hbase_checkAndPut_args {
 public:

  static const char* ascii_fingerprint; // = "5D6D765367FF9EEC64FC0E02FF02FC2D";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0x6D,0x76,0x53,0x67,0xFF,0x9E,0xEC,0x64,0xFC,0x0E,0x02,0xFF,0x02,0xFC,0x2D};

  Hbase_checkAndPut_args(const Hbase_checkAndPut_args&);
  Hbase_checkAndPut_args& operator=(const Hbase_checkAndPut_args&);
  Hbase_checkAndPut_args() : tableName(), row(), column(), value() {
  }

  virtual ~Hbase_checkAndPut_args() throw();
  Text tableName;
  Text row;
  Text column;
  Text value;
  Mutation mput;
  std::map<Text, Text>  attributes;

  _Hbase_checkAndPut_args__isset __isset;

  void __set_tableName(const Text& val);

  void __set_row(const Text& val);

  void __set_column(const Text& val);

  void __set_value(const Text& val);

  void __set_mput(const Mutation& val);

  void __set_attributes(const std::map<Text, Text> & val);

  bool operator == (const Hbase_checkAndPut_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(mput == rhs.mput))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_checkAndPut_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_checkAndPut_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_checkAndPut_args& obj);
};


class Hbase_checkAndPut_pargs {
 public:

  static const char* ascii_fingerprint; // = "5D6D765367FF9EEC64FC0E02FF02FC2D";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0x6D,0x76,0x53,0x67,0xFF,0x9E,0xEC,0x64,0xFC,0x0E,0x02,0xFF,0x02,0xFC,0x2D};


  virtual ~Hbase_checkAndPut_pargs() throw();
  const Text* tableName;
  const Text* row;
  const Text* column;
  const Text* value;
  const Mutation* mput;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_checkAndPut_pargs& obj);
};

typedef struct _Hbase_checkAndPut_result__isset {
  _Hbase_checkAndPut_result__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_checkAndPut_result__isset;

class Hbase_checkAndPut_result {
 public:

  static const char* ascii_fingerprint; // = "3499095F5992356B85332339F1B55814";
  static const uint8_t binary_fingerprint[16]; // = {0x34,0x99,0x09,0x5F,0x59,0x92,0x35,0x6B,0x85,0x33,0x23,0x39,0xF1,0xB5,0x58,0x14};

  Hbase_checkAndPut_result(const Hbase_checkAndPut_result&);
  Hbase_checkAndPut_result& operator=(const Hbase_checkAndPut_result&);
  Hbase_checkAndPut_result() : success(0) {
  }

  virtual ~Hbase_checkAndPut_result() throw();
  bool success;
  IOError io;
  IllegalArgument ia;

  _Hbase_checkAndPut_result__isset __isset;

  void __set_success(const bool val);

  void __set_io(const IOError& val);

  void __set_ia(const IllegalArgument& val);

  bool operator == (const Hbase_checkAndPut_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_checkAndPut_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_checkAndPut_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Hbase_checkAndPut_result& obj);
};

typedef struct _Hbase_checkAndPut_presult__isset {
  _Hbase_checkAndPut_presult__isset() : success(false), io(false), ia(false) {}
  bool success :1;
  bool io :1;
  bool ia :1;
} _Hbase_checkAndPut_presult__isset;

class Hbase_checkAndPut_presult {
 public:

  static const char* ascii_fingerprint; // = "3499095F5992356B85332339F1B55814";
  static const uint8_t binary_fingerprint[16]; // = {0x34,0x99,0x09,0x5F,0x59,0x92,0x35,0x6B,0x85,0x33,0x23,0x39,0xF1,0xB5,0x58,0x14};


  virtual ~Hbase_checkAndPut_presult() throw();
  bool* success;
  IOError io;
  IllegalArgument ia;

  _Hbase_checkAndPut_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

  friend std::ostream& operator<<(std::ostream& out, const Hbase_checkAndPut_presult& obj);
};

class HbaseClient : virtual public HbaseIf {
 public:
  HbaseClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HbaseClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void enableTable(const Bytes& tableName);
  void send_enableTable(const Bytes& tableName);
  void recv_enableTable();
  void disableTable(const Bytes& tableName);
  void send_disableTable(const Bytes& tableName);
  void recv_disableTable();
  bool isTableEnabled(const Bytes& tableName);
  void send_isTableEnabled(const Bytes& tableName);
  bool recv_isTableEnabled();
  void compact(const Bytes& tableNameOrRegionName);
  void send_compact(const Bytes& tableNameOrRegionName);
  void recv_compact();
  void majorCompact(const Bytes& tableNameOrRegionName);
  void send_majorCompact(const Bytes& tableNameOrRegionName);
  void recv_majorCompact();
  void getTableNames(std::vector<Text> & _return);
  void send_getTableNames();
  void recv_getTableNames(std::vector<Text> & _return);
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName);
  void send_getColumnDescriptors(const Text& tableName);
  void recv_getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return);
  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName);
  void send_getTableRegions(const Text& tableName);
  void recv_getTableRegions(std::vector<TRegionInfo> & _return);
  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void send_createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void recv_createTable();
  void deleteTable(const Text& tableName);
  void send_deleteTable(const Text& tableName);
  void recv_deleteTable();
  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void send_get(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void recv_get(std::vector<TCell> & _return);
  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void send_getVer(const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void recv_getVer(std::vector<TCell> & _return);
  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void send_getVerTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void recv_getVerTs(std::vector<TCell> & _return);
  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_getRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_getRow(std::vector<TRowResult> & _return);
  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_getRowWithColumns(const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void recv_getRowWithColumns(std::vector<TRowResult> & _return);
  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowTs(std::vector<TRowResult> & _return);
  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowWithColumnsTs(const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowWithColumnsTs(std::vector<TRowResult> & _return);
  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes);
  void send_getRows(const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes);
  void recv_getRows(std::vector<TRowResult> & _return);
  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_getRowsWithColumns(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void recv_getRowsWithColumns(std::vector<TRowResult> & _return);
  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowsTs(const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowsTs(std::vector<TRowResult> & _return);
  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowsWithColumnsTs(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowsWithColumnsTs(std::vector<TRowResult> & _return);
  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void send_mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void recv_mutateRow();
  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowTs();
  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void send_mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void recv_mutateRows();
  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowsTs();
  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  void send_atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  int64_t recv_atomicIncrement();
  void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void send_deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void recv_deleteAll();
  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_deleteAllTs();
  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_deleteAllRow();
  void increment(const TIncrement& increment);
  void send_increment(const TIncrement& increment);
  void recv_increment();
  void incrementRows(const std::vector<TIncrement> & increments);
  void send_incrementRows(const std::vector<TIncrement> & increments);
  void recv_incrementRows();
  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_deleteAllRowTs();
  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithScan();
  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpen();
  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithStop();
  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithPrefix();
  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenTs();
  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithStopTs();
  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id);
  void send_scannerGet(const ScannerID id);
  void recv_scannerGet(std::vector<TRowResult> & _return);
  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows);
  void send_scannerGetList(const ScannerID id, const int32_t nbRows);
  void recv_scannerGetList(std::vector<TRowResult> & _return);
  void scannerClose(const ScannerID id);
  void send_scannerClose(const ScannerID id);
  void recv_scannerClose();
  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family);
  void send_getRowOrBefore(const Text& tableName, const Text& row, const Text& family);
  void recv_getRowOrBefore(std::vector<TCell> & _return);
  void getRegionInfo(TRegionInfo& _return, const Text& row);
  void send_getRegionInfo(const Text& row);
  void recv_getRegionInfo(TRegionInfo& _return);
  void append(std::vector<TCell> & _return, const TAppend& append);
  void send_append(const TAppend& append);
  void recv_append(std::vector<TCell> & _return);
  bool checkAndPut(const Text& tableName, const Text& row, const Text& column, const Text& value, const Mutation& mput, const std::map<Text, Text> & attributes);
  void send_checkAndPut(const Text& tableName, const Text& row, const Text& column, const Text& value, const Mutation& mput, const std::map<Text, Text> & attributes);
  bool recv_checkAndPut();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HbaseProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<HbaseIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (HbaseProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_enableTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disableTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isTableEnabled(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_majorCompact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableNames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getColumnDescriptors(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableRegions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getVer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getVerTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumns(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumnsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsWithColumns(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsWithColumnsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_atomicIncrement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_increment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_incrementRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpen(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithPrefix(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerGet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerGetList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerClose(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowOrBefore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRegionInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_append(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_checkAndPut(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  HbaseProcessor(boost::shared_ptr<HbaseIf> iface) :
    iface_(iface) {
    processMap_["enableTable"] = &HbaseProcessor::process_enableTable;
    processMap_["disableTable"] = &HbaseProcessor::process_disableTable;
    processMap_["isTableEnabled"] = &HbaseProcessor::process_isTableEnabled;
    processMap_["compact"] = &HbaseProcessor::process_compact;
    processMap_["majorCompact"] = &HbaseProcessor::process_majorCompact;
    processMap_["getTableNames"] = &HbaseProcessor::process_getTableNames;
    processMap_["getColumnDescriptors"] = &HbaseProcessor::process_getColumnDescriptors;
    processMap_["getTableRegions"] = &HbaseProcessor::process_getTableRegions;
    processMap_["createTable"] = &HbaseProcessor::process_createTable;
    processMap_["deleteTable"] = &HbaseProcessor::process_deleteTable;
    processMap_["get"] = &HbaseProcessor::process_get;
    processMap_["getVer"] = &HbaseProcessor::process_getVer;
    processMap_["getVerTs"] = &HbaseProcessor::process_getVerTs;
    processMap_["getRow"] = &HbaseProcessor::process_getRow;
    processMap_["getRowWithColumns"] = &HbaseProcessor::process_getRowWithColumns;
    processMap_["getRowTs"] = &HbaseProcessor::process_getRowTs;
    processMap_["getRowWithColumnsTs"] = &HbaseProcessor::process_getRowWithColumnsTs;
    processMap_["getRows"] = &HbaseProcessor::process_getRows;
    processMap_["getRowsWithColumns"] = &HbaseProcessor::process_getRowsWithColumns;
    processMap_["getRowsTs"] = &HbaseProcessor::process_getRowsTs;
    processMap_["getRowsWithColumnsTs"] = &HbaseProcessor::process_getRowsWithColumnsTs;
    processMap_["mutateRow"] = &HbaseProcessor::process_mutateRow;
    processMap_["mutateRowTs"] = &HbaseProcessor::process_mutateRowTs;
    processMap_["mutateRows"] = &HbaseProcessor::process_mutateRows;
    processMap_["mutateRowsTs"] = &HbaseProcessor::process_mutateRowsTs;
    processMap_["atomicIncrement"] = &HbaseProcessor::process_atomicIncrement;
    processMap_["deleteAll"] = &HbaseProcessor::process_deleteAll;
    processMap_["deleteAllTs"] = &HbaseProcessor::process_deleteAllTs;
    processMap_["deleteAllRow"] = &HbaseProcessor::process_deleteAllRow;
    processMap_["increment"] = &HbaseProcessor::process_increment;
    processMap_["incrementRows"] = &HbaseProcessor::process_incrementRows;
    processMap_["deleteAllRowTs"] = &HbaseProcessor::process_deleteAllRowTs;
    processMap_["scannerOpenWithScan"] = &HbaseProcessor::process_scannerOpenWithScan;
    processMap_["scannerOpen"] = &HbaseProcessor::process_scannerOpen;
    processMap_["scannerOpenWithStop"] = &HbaseProcessor::process_scannerOpenWithStop;
    processMap_["scannerOpenWithPrefix"] = &HbaseProcessor::process_scannerOpenWithPrefix;
    processMap_["scannerOpenTs"] = &HbaseProcessor::process_scannerOpenTs;
    processMap_["scannerOpenWithStopTs"] = &HbaseProcessor::process_scannerOpenWithStopTs;
    processMap_["scannerGet"] = &HbaseProcessor::process_scannerGet;
    processMap_["scannerGetList"] = &HbaseProcessor::process_scannerGetList;
    processMap_["scannerClose"] = &HbaseProcessor::process_scannerClose;
    processMap_["getRowOrBefore"] = &HbaseProcessor::process_getRowOrBefore;
    processMap_["getRegionInfo"] = &HbaseProcessor::process_getRegionInfo;
    processMap_["append"] = &HbaseProcessor::process_append;
    processMap_["checkAndPut"] = &HbaseProcessor::process_checkAndPut;
  }

  virtual ~HbaseProcessor() {}
};

class HbaseProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HbaseProcessorFactory(const ::boost::shared_ptr< HbaseIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< HbaseIfFactory > handlerFactory_;
};

class HbaseMultiface : virtual public HbaseIf {
 public:
  HbaseMultiface(std::vector<boost::shared_ptr<HbaseIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HbaseMultiface() {}
 protected:
  std::vector<boost::shared_ptr<HbaseIf> > ifaces_;
  HbaseMultiface() {}
  void add(boost::shared_ptr<HbaseIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void enableTable(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enableTable(tableName);
    }
    ifaces_[i]->enableTable(tableName);
  }

  void disableTable(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disableTable(tableName);
    }
    ifaces_[i]->disableTable(tableName);
  }

  bool isTableEnabled(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->isTableEnabled(tableName);
    }
    return ifaces_[i]->isTableEnabled(tableName);
  }

  void compact(const Bytes& tableNameOrRegionName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->compact(tableNameOrRegionName);
    }
    ifaces_[i]->compact(tableNameOrRegionName);
  }

  void majorCompact(const Bytes& tableNameOrRegionName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->majorCompact(tableNameOrRegionName);
    }
    ifaces_[i]->majorCompact(tableNameOrRegionName);
  }

  void getTableNames(std::vector<Text> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTableNames(_return);
    }
    ifaces_[i]->getTableNames(_return);
    return;
  }

  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getColumnDescriptors(_return, tableName);
    }
    ifaces_[i]->getColumnDescriptors(_return, tableName);
    return;
  }

  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTableRegions(_return, tableName);
    }
    ifaces_[i]->getTableRegions(_return, tableName);
    return;
  }

  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createTable(tableName, columnFamilies);
    }
    ifaces_[i]->createTable(tableName, columnFamilies);
  }

  void deleteTable(const Text& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteTable(tableName);
    }
    ifaces_[i]->deleteTable(tableName);
  }

  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get(_return, tableName, row, column, attributes);
    }
    ifaces_[i]->get(_return, tableName, row, column, attributes);
    return;
  }

  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getVer(_return, tableName, row, column, numVersions, attributes);
    }
    ifaces_[i]->getVer(_return, tableName, row, column, numVersions, attributes);
    return;
  }

  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions, attributes);
    }
    ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions, attributes);
    return;
  }

  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRow(_return, tableName, row, attributes);
    }
    ifaces_[i]->getRow(_return, tableName, row, attributes);
    return;
  }

  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowWithColumns(_return, tableName, row, columns, attributes);
    }
    ifaces_[i]->getRowWithColumns(_return, tableName, row, columns, attributes);
    return;
  }

  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowTs(_return, tableName, row, timestamp, attributes);
    }
    ifaces_[i]->getRowTs(_return, tableName, row, timestamp, attributes);
    return;
  }

  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp, attributes);
    }
    ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp, attributes);
    return;
  }

  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRows(_return, tableName, rows, attributes);
    }
    ifaces_[i]->getRows(_return, tableName, rows, attributes);
    return;
  }

  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowsWithColumns(_return, tableName, rows, columns, attributes);
    }
    ifaces_[i]->getRowsWithColumns(_return, tableName, rows, columns, attributes);
    return;
  }

  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp, attributes);
    }
    ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp, attributes);
    return;
  }

  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp, attributes);
    }
    ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp, attributes);
    return;
  }

  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRow(tableName, row, mutations, attributes);
    }
    ifaces_[i]->mutateRow(tableName, row, mutations, attributes);
  }

  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRowTs(tableName, row, mutations, timestamp, attributes);
    }
    ifaces_[i]->mutateRowTs(tableName, row, mutations, timestamp, attributes);
  }

  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRows(tableName, rowBatches, attributes);
    }
    ifaces_[i]->mutateRows(tableName, rowBatches, attributes);
  }

  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRowsTs(tableName, rowBatches, timestamp, attributes);
    }
    ifaces_[i]->mutateRowsTs(tableName, rowBatches, timestamp, attributes);
  }

  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->atomicIncrement(tableName, row, column, value);
    }
    return ifaces_[i]->atomicIncrement(tableName, row, column, value);
  }

  void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAll(tableName, row, column, attributes);
    }
    ifaces_[i]->deleteAll(tableName, row, column, attributes);
  }

  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAllTs(tableName, row, column, timestamp, attributes);
    }
    ifaces_[i]->deleteAllTs(tableName, row, column, timestamp, attributes);
  }

  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAllRow(tableName, row, attributes);
    }
    ifaces_[i]->deleteAllRow(tableName, row, attributes);
  }

  void increment(const TIncrement& increment) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->increment(increment);
    }
    ifaces_[i]->increment(increment);
  }

  void incrementRows(const std::vector<TIncrement> & increments) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->incrementRows(increments);
    }
    ifaces_[i]->incrementRows(increments);
  }

  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAllRowTs(tableName, row, timestamp, attributes);
    }
    ifaces_[i]->deleteAllRowTs(tableName, row, timestamp, attributes);
  }

  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithScan(tableName, scan, attributes);
    }
    return ifaces_[i]->scannerOpenWithScan(tableName, scan, attributes);
  }

  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpen(tableName, startRow, columns, attributes);
    }
    return ifaces_[i]->scannerOpen(tableName, startRow, columns, attributes);
  }

  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
    }
    return ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
  }

  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
    }
    return ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
  }

  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
    }
    return ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
  }

  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
    }
    return ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
  }

  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerGet(_return, id);
    }
    ifaces_[i]->scannerGet(_return, id);
    return;
  }

  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerGetList(_return, id, nbRows);
    }
    ifaces_[i]->scannerGetList(_return, id, nbRows);
    return;
  }

  void scannerClose(const ScannerID id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerClose(id);
    }
    ifaces_[i]->scannerClose(id);
  }

  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
    }
    ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
    return;
  }

  void getRegionInfo(TRegionInfo& _return, const Text& row) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRegionInfo(_return, row);
    }
    ifaces_[i]->getRegionInfo(_return, row);
    return;
  }

  void append(std::vector<TCell> & _return, const TAppend& append) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->append(_return, append);
    }
    ifaces_[i]->append(_return, append);
    return;
  }

  bool checkAndPut(const Text& tableName, const Text& row, const Text& column, const Text& value, const Mutation& mput, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->checkAndPut(tableName, row, column, value, mput, attributes);
    }
    return ifaces_[i]->checkAndPut(tableName, row, column, value, mput, attributes);
  }

};

}}}} // namespace

#endif
